var Rollup = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var clusterize_min = createCommonjsModule(function (module) {
	(function(q,n){module.exports=n();})("Clusterize",function(){function q(b,a,c){return a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c)}function n(b,a,c){return a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c)}function r(b){return "[object Array]"===Object.prototype.toString.call(b)}function m(b,a){return window.getComputedStyle?window.getComputedStyle(a)[b]:
		a.currentStyle[b]}var l=function(){for(var b=3,a=document.createElement("b"),c=a.all||[];a.innerHTML="\x3c!--[if gt IE "+ ++b+"]><i><![endif]--\x3e",c[0];){ }return 4<b?b:document.documentMode}(),x=navigator.platform.toLowerCase().indexOf("mac")+1,p=function(b){if(!(this instanceof p)){ return new p(b); }var a=this,c={rows_in_block:50,blocks_in_cluster:4,tag:null,show_no_data_row:!0,no_data_class:"clusterize-no-data",no_data_text:"No data",keep_parity:!0,callbacks:{}};a.options={};for(var d="rows_in_block blocks_in_cluster show_no_data_row no_data_class no_data_text keep_parity tag callbacks".split(" "),
		f=0,h;h=d[f];f++){ a.options[h]="undefined"!=typeof b[h]&&null!=b[h]?b[h]:c[h]; }c=["scroll","content"];for(f=0;d=c[f];f++){ if(a[d+"_elem"]=b[d+"Id"]?document.getElementById(b[d+"Id"]):b[d+"Elem"],!a[d+"_elem"]){ throw Error("Error! Could not find "+d+" element"); } }a.content_elem.hasAttribute("tabindex")||a.content_elem.setAttribute("tabindex",0);var e=r(b.rows)?b.rows:a.fetchMarkup(),g={};b=a.scroll_elem.scrollTop;a.insertToDOM(e,g);a.scroll_elem.scrollTop=b;var k=!1,m=0,l=!1,t=function(){x&&(l||(a.content_elem.style.pointerEvents=
		"none"),l=!0,clearTimeout(m),m=setTimeout(function(){a.content_elem.style.pointerEvents="auto";l=!1;},50));k!=(k=a.getClusterNum())&&a.insertToDOM(e,g);a.options.callbacks.scrollingProgress&&a.options.callbacks.scrollingProgress(a.getScrollProgress());},u=0,v=function(){clearTimeout(u);u=setTimeout(a.refresh,100);};q("scroll",a.scroll_elem,t);q("resize",window,v);a.destroy=function(b){n("scroll",a.scroll_elem,t);n("resize",window,v);a.html((b?a.generateEmptyRow():e).join(""));};a.refresh=function(b){(a.getRowsHeight(e)||
		b)&&a.update(e);};a.update=function(b){e=r(b)?b:[];b=a.scroll_elem.scrollTop;e.length*a.options.item_height<b&&(k=a.scroll_elem.scrollTop=0);a.insertToDOM(e,g);a.scroll_elem.scrollTop=b;};a.clear=function(){a.update([]);};a.getRowsAmount=function(){return e.length};a.getScrollProgress=function(){return this.options.scroll_top/(e.length*this.options.item_height)*100||0};var w=function(b,c){var d=r(c)?c:[];d.length&&(e="append"==b?e.concat(d):d.concat(e),a.insertToDOM(e,g));};a.append=function(a){w("append",
		a);};a.prepend=function(a){w("prepend",a);};};p.prototype={constructor:p,fetchMarkup:function(){for(var b=[],a=this.getChildNodes(this.content_elem);a.length;){ b.push(a.shift().outerHTML); }return b},exploreEnvironment:function(b,a){var c=this.options;c.content_tag=this.content_elem.tagName.toLowerCase();b.length&&(l&&9>=l&&!c.tag&&(c.tag=b[0].match(/<([^>\s/]*)/)[1].toLowerCase()),1>=this.content_elem.children.length&&(a.data=this.html(b[0]+b[0]+b[0])),c.tag||(c.tag=this.content_elem.children[0].tagName.toLowerCase()),
		this.getRowsHeight(b));},getRowsHeight:function(b){var a=this.options,c=a.item_height;a.cluster_height=0;if(b.length){b=this.content_elem.children;var d=b[Math.floor(b.length/2)];a.item_height=d.offsetHeight;"tr"==a.tag&&"collapse"!=m("borderCollapse",this.content_elem)&&(a.item_height+=parseInt(m("borderSpacing",this.content_elem),10)||0);"tr"!=a.tag&&(b=parseInt(m("marginTop",d),10)||0,d=parseInt(m("marginBottom",d),10)||0,a.item_height+=Math.max(b,d));a.block_height=a.item_height*a.rows_in_block;
		a.rows_in_cluster=a.blocks_in_cluster*a.rows_in_block;a.cluster_height=a.blocks_in_cluster*a.block_height;return c!=a.item_height}},getClusterNum:function(){this.options.scroll_top=this.scroll_elem.scrollTop;return Math.floor(this.options.scroll_top/(this.options.cluster_height-this.options.block_height))||0},generateEmptyRow:function(){var b=this.options;if(!b.tag||!b.show_no_data_row){ return []; }var a=document.createElement(b.tag),c=document.createTextNode(b.no_data_text),d;a.className=b.no_data_class;
		"tr"==b.tag&&(d=document.createElement("td"),d.colSpan=100,d.appendChild(c));a.appendChild(d||c);return [a.outerHTML]},generate:function(b,a){var c=this.options,d=b.length;if(d<c.rows_in_block){ return {top_offset:0,bottom_offset:0,rows_above:0,rows:d?b:this.generateEmptyRow()}; }var f=Math.max((c.rows_in_cluster-c.rows_in_block)*a,0),h=f+c.rows_in_cluster,e=Math.max(f*c.item_height,0),c=Math.max((d-h)*c.item_height,0),d=[],g=f;for(1>e&&g++;f<h;f++){ b[f]&&d.push(b[f]); }return {top_offset:e,bottom_offset:c,
		rows_above:g,rows:d}},renderExtraTag:function(b,a){var c=document.createElement(this.options.tag);c.className=["clusterize-extra-row","clusterize-"+b].join(" ");a&&(c.style.height=a+"px");return c.outerHTML},insertToDOM:function(b,a){this.options.cluster_height||this.exploreEnvironment(b,a);var c=this.generate(b,this.getClusterNum()),d=c.rows.join(""),f=this.checkChanges("data",d,a),h=this.checkChanges("top",c.top_offset,a),e=this.checkChanges("bottom",c.bottom_offset,a),g=this.options.callbacks,
		k=[];f||h?(c.top_offset&&(this.options.keep_parity&&k.push(this.renderExtraTag("keep-parity")),k.push(this.renderExtraTag("top-space",c.top_offset))),k.push(d),c.bottom_offset&&k.push(this.renderExtraTag("bottom-space",c.bottom_offset)),g.clusterWillChange&&g.clusterWillChange(),this.html(k.join("")),"ol"==this.options.content_tag&&this.content_elem.setAttribute("start",c.rows_above),g.clusterChanged&&g.clusterChanged()):e&&(this.content_elem.lastChild.style.height=c.bottom_offset+"px");},html:function(b){var a=
		this.content_elem;if(l&&9>=l&&"tr"==this.options.tag){var c=document.createElement("div");for(c.innerHTML="<table><tbody>"+b+"</tbody></table>";b=a.lastChild;){ a.removeChild(b); }for(c=this.getChildNodes(c.firstChild.firstChild);c.length;){ a.appendChild(c.shift()); }}else { a.innerHTML=b; }},getChildNodes:function(b){b=b.children;for(var a=[],c=0,d=b.length;c<d;c++){ a.push(b[c]); }return a},checkChanges:function(b,a,c){var d=a!=c[b];c[b]=a;return d}};return p});
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.views.ReportFactory = class ReportFactory extends frappe.views.Factory {
		make(route) {
			var _route = ['List', route[1], 'Report'];

			if (route[2]) {
				// custom report
				_route.push(route[2]);
			}

			frappe.set_route(_route);
		}
	};

	var Sortable = createCommonjsModule(function (module) {
	/**!
	 * Sortable
	 * @author	RubaXa   <trash@rubaxa.org>
	 * @license MIT
	 */

	(function sortableModule(factory) {

		{
			module.exports = factory();
		}
	})(function sortableFactory() {

		if (typeof window === "undefined" || !window.document) {
			return function sortableError() {
				throw new Error("Sortable.js requires a window with a document");
			};
		}

		var dragEl,
			parentEl,
			ghostEl,
			cloneEl,
			rootEl,
			nextEl,
			lastDownEl,

			scrollEl,
			scrollParentEl,
			scrollCustomFn,

			lastEl,
			lastCSS,
			lastParentCSS,

			oldIndex,
			newIndex,

			activeGroup,
			putSortable,

			autoScroll = {},

			tapEvt,
			touchEvt,

			moved,

			/** @const */
			R_SPACE = /\s+/g,
			R_FLOAT = /left|right|inline/,

			expando = 'Sortable' + (new Date).getTime(),

			win = window,
			document = win.document,
			parseInt = win.parseInt,
			setTimeout = win.setTimeout,

			$ = win.jQuery || win.Zepto,
			Polymer = win.Polymer,

			captureMode = false,
			passiveMode = false,

			supportDraggable = ('draggable' in document.createElement('div')),
			supportCssPointerEvents = (function (el) {
				// false when IE11
				if (!!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie)/i)) {
					return false;
				}
				el = document.createElement('x');
				el.style.cssText = 'pointer-events:auto';
				return el.style.pointerEvents === 'auto';
			})(),

			_silent = false,

			abs = Math.abs,
			min = Math.min,

			savedInputChecked = [],
			touchDragOverListeners = [],

			_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
				// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
				if (rootEl && options.scroll) {
					var _this = rootEl[expando],
						el,
						rect,
						sens = options.scrollSensitivity,
						speed = options.scrollSpeed,

						x = evt.clientX,
						y = evt.clientY,

						winWidth = window.innerWidth,
						winHeight = window.innerHeight,

						vx,
						vy,

						scrollOffsetX,
						scrollOffsetY
					;

					// Delect scrollEl
					if (scrollParentEl !== rootEl) {
						scrollEl = options.scroll;
						scrollParentEl = rootEl;
						scrollCustomFn = options.scrollFn;

						if (scrollEl === true) {
							scrollEl = rootEl;

							do {
								if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
									(scrollEl.offsetHeight < scrollEl.scrollHeight)
								) {
									break;
								}
								/* jshint boss:true */
							} while (scrollEl = scrollEl.parentNode);
						}
					}

					if (scrollEl) {
						el = scrollEl;
						rect = scrollEl.getBoundingClientRect();
						vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
						vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
					}


					if (!(vx || vy)) {
						vx = (winWidth - x <= sens) - (x <= sens);
						vy = (winHeight - y <= sens) - (y <= sens);

						/* jshint expr:true */
						(vx || vy) && (el = win);
					}


					if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
						autoScroll.el = el;
						autoScroll.vx = vx;
						autoScroll.vy = vy;

						clearInterval(autoScroll.pid);

						if (el) {
							autoScroll.pid = setInterval(function () {
								scrollOffsetY = vy ? vy * speed : 0;
								scrollOffsetX = vx ? vx * speed : 0;

								if ('function' === typeof(scrollCustomFn)) {
									return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
								}

								if (el === win) {
									win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
								} else {
									el.scrollTop += scrollOffsetY;
									el.scrollLeft += scrollOffsetX;
								}
							}, 24);
						}
					}
				}
			}, 30),

			_prepareGroup = function (options) {
				function toFn(value, pull) {
					if (value === void 0 || value === true) {
						value = group.name;
					}

					if (typeof value === 'function') {
						return value;
					} else {
						return function (to, from) {
							var fromGroup = from.options.group.name;

							return pull
								? value
								: value && (value.join
									? value.indexOf(fromGroup) > -1
									: (fromGroup == value)
								);
						};
					}
				}

				var group = {};
				var originalGroup = options.group;

				if (!originalGroup || typeof originalGroup != 'object') {
					originalGroup = {name: originalGroup};
				}

				group.name = originalGroup.name;
				group.checkPull = toFn(originalGroup.pull, true);
				group.checkPut = toFn(originalGroup.put);
				group.revertClone = originalGroup.revertClone;

				options.group = group;
			}
		;

		// Detect support a passive mode
		try {
			window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
				get: function () {
					// `false`, because everything starts to work incorrectly and instead of d'n'd,
					// begins the page has scrolled.
					passiveMode = false;
					captureMode = {
						capture: false,
						passive: passiveMode
					};
				}
			}));
		} catch (err) {}

		/**
		 * @class  Sortable
		 * @param  {HTMLElement}  el
		 * @param  {Object}       [options]
		 */
		function Sortable(el, options) {
			var this$1 = this;

			if (!(el && el.nodeType && el.nodeType === 1)) {
				throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
			}

			this.el = el; // root element
			this.options = options = _extend({}, options);


			// Export instance
			el[expando] = this;

			// Default options
			var defaults = {
				group: Math.random(),
				sort: true,
				disabled: false,
				store: null,
				handle: null,
				scroll: true,
				scrollSensitivity: 30,
				scrollSpeed: 10,
				draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
				ghostClass: 'sortable-ghost',
				chosenClass: 'sortable-chosen',
				dragClass: 'sortable-drag',
				ignore: 'a, img',
				filter: null,
				preventOnFilter: true,
				animation: 0,
				setData: function (dataTransfer, dragEl) {
					dataTransfer.setData('Text', dragEl.textContent);
				},
				dropBubble: false,
				dragoverBubble: false,
				dataIdAttr: 'data-id',
				delay: 0,
				forceFallback: false,
				fallbackClass: 'sortable-fallback',
				fallbackOnBody: false,
				fallbackTolerance: 0,
				fallbackOffset: {x: 0, y: 0},
				supportPointer: Sortable.supportPointer !== false
			};


			// Set default options
			for (var name in defaults) {
				!(name in options) && (options[name] = defaults[name]);
			}

			_prepareGroup(options);

			// Bind all private methods
			for (var fn in this$1) {
				if (fn.charAt(0) === '_' && typeof this$1[fn] === 'function') {
					this$1[fn] = this$1[fn].bind(this$1);
				}
			}

			// Setup drag mode
			this.nativeDraggable = options.forceFallback ? false : supportDraggable;

			// Bind events
			_on(el, 'mousedown', this._onTapStart);
			_on(el, 'touchstart', this._onTapStart);
			options.supportPointer && _on(el, 'pointerdown', this._onTapStart);

			if (this.nativeDraggable) {
				_on(el, 'dragover', this);
				_on(el, 'dragenter', this);
			}

			touchDragOverListeners.push(this._onDragOver);

			// Restore sorting
			options.store && this.sort(options.store.get(this));
		}


		Sortable.prototype = /** @lends Sortable.prototype */ {
			constructor: Sortable,

			_onTapStart: function (/** Event|TouchEvent */evt) {
				var _this = this,
					el = this.el,
					options = this.options,
					preventOnFilter = options.preventOnFilter,
					type = evt.type,
					touch = evt.touches && evt.touches[0],
					target = (touch || evt).target,
					originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target,
					filter = options.filter,
					startIndex;

				_saveInputCheckedState(el);


				// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
				if (dragEl) {
					return;
				}

				if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
					return; // only left button or enabled
				}

				// cancel dnd if original target is content editable
				if (originalTarget.isContentEditable) {
					return;
				}

				target = _closest(target, options.draggable, el);

				if (!target) {
					return;
				}

				if (lastDownEl === target) {
					// Ignoring duplicate `down`
					return;
				}

				// Get the index of the dragged element within its parent
				startIndex = _index(target, options.draggable);

				// Check filter
				if (typeof filter === 'function') {
					if (filter.call(this, evt, target, this)) {
						_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
						preventOnFilter && evt.preventDefault();
						return; // cancel dnd
					}
				}
				else if (filter) {
					filter = filter.split(',').some(function (criteria) {
						criteria = _closest(originalTarget, criteria.trim(), el);

						if (criteria) {
							_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
							return true;
						}
					});

					if (filter) {
						preventOnFilter && evt.preventDefault();
						return; // cancel dnd
					}
				}

				if (options.handle && !_closest(originalTarget, options.handle, el)) {
					return;
				}

				// Prepare `dragstart`
				this._prepareDragStart(evt, touch, target, startIndex);
			},

			_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
				var _this = this,
					el = _this.el,
					options = _this.options,
					ownerDocument = el.ownerDocument,
					dragStartFn;

				if (target && !dragEl && (target.parentNode === el)) {
					tapEvt = evt;

					rootEl = el;
					dragEl = target;
					parentEl = dragEl.parentNode;
					nextEl = dragEl.nextSibling;
					lastDownEl = target;
					activeGroup = options.group;
					oldIndex = startIndex;

					this._lastX = (touch || evt).clientX;
					this._lastY = (touch || evt).clientY;

					dragEl.style['will-change'] = 'all';

					dragStartFn = function () {
						// Delayed drag has been triggered
						// we can re-enable the events: touchmove/mousemove
						_this._disableDelayedDrag();

						// Make the element draggable
						dragEl.draggable = _this.nativeDraggable;

						// Chosen item
						_toggleClass(dragEl, options.chosenClass, true);

						// Bind the events: dragstart/dragend
						_this._triggerDragStart(evt, touch);

						// Drag start event
						_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);
					};

					// Disable "draggable"
					options.ignore.split(',').forEach(function (criteria) {
						_find(dragEl, criteria.trim(), _disableDraggable);
					});

					_on(ownerDocument, 'mouseup', _this._onDrop);
					_on(ownerDocument, 'touchend', _this._onDrop);
					_on(ownerDocument, 'touchcancel', _this._onDrop);
					_on(ownerDocument, 'selectstart', _this);
					options.supportPointer && _on(ownerDocument, 'pointercancel', _this._onDrop);

					if (options.delay) {
						// If the user moves the pointer or let go the click or touch
						// before the delay has been reached:
						// disable the delayed drag
						_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
						_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
						_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
						options.supportPointer && _on(ownerDocument, 'pointermove', _this._disableDelayedDrag);

						_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
					} else {
						dragStartFn();
					}


				}
			},

			_disableDelayedDrag: function () {
				var ownerDocument = this.el.ownerDocument;

				clearTimeout(this._dragStartTimer);
				_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
				_off(ownerDocument, 'touchend', this._disableDelayedDrag);
				_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
				_off(ownerDocument, 'mousemove', this._disableDelayedDrag);
				_off(ownerDocument, 'touchmove', this._disableDelayedDrag);
				_off(ownerDocument, 'pointermove', this._disableDelayedDrag);
			},

			_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
				touch = touch || (evt.pointerType == 'touch' ? evt : null);

				if (touch) {
					// Touch device support
					tapEvt = {
						target: dragEl,
						clientX: touch.clientX,
						clientY: touch.clientY
					};

					this._onDragStart(tapEvt, 'touch');
				}
				else if (!this.nativeDraggable) {
					this._onDragStart(tapEvt, true);
				}
				else {
					_on(dragEl, 'dragend', this);
					_on(rootEl, 'dragstart', this._onDragStart);
				}

				try {
					if (document.selection) {
						// Timeout neccessary for IE9
						_nextTick(function () {
							document.selection.empty();
						});
					} else {
						window.getSelection().removeAllRanges();
					}
				} catch (err) {
				}
			},

			_dragStarted: function () {
				if (rootEl && dragEl) {
					var options = this.options;

					// Apply effect
					_toggleClass(dragEl, options.ghostClass, true);
					_toggleClass(dragEl, options.dragClass, false);

					Sortable.active = this;

					// Drag start event
					_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
				} else {
					this._nulling();
				}
			},

			_emulateDragOver: function () {
				if (touchEvt) {
					if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
						return;
					}

					this._lastX = touchEvt.clientX;
					this._lastY = touchEvt.clientY;

					if (!supportCssPointerEvents) {
						_css(ghostEl, 'display', 'none');
					}

					var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
					var parent = target;
					var i = touchDragOverListeners.length;

					if (target && target.shadowRoot) {
						target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
						parent = target;
					}

					if (parent) {
						do {
							if (parent[expando]) {
								while (i--) {
									touchDragOverListeners[i]({
										clientX: touchEvt.clientX,
										clientY: touchEvt.clientY,
										target: target,
										rootEl: parent
									});
								}

								break;
							}

							target = parent; // store last element
						}
						/* jshint boss:true */
						while (parent = parent.parentNode);
					}

					if (!supportCssPointerEvents) {
						_css(ghostEl, 'display', '');
					}
				}
			},


			_onTouchMove: function (/**TouchEvent*/evt) {
				if (tapEvt) {
					var	options = this.options,
						fallbackTolerance = options.fallbackTolerance,
						fallbackOffset = options.fallbackOffset,
						touch = evt.touches ? evt.touches[0] : evt,
						dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,
						dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,
						translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

					// only set the status to dragging, when we are actually dragging
					if (!Sortable.active) {
						if (fallbackTolerance &&
							min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
						) {
							return;
						}

						this._dragStarted();
					}

					// as well as creating the ghost element on the document body
					this._appendGhost();

					moved = true;
					touchEvt = touch;

					_css(ghostEl, 'webkitTransform', translate3d);
					_css(ghostEl, 'mozTransform', translate3d);
					_css(ghostEl, 'msTransform', translate3d);
					_css(ghostEl, 'transform', translate3d);

					evt.preventDefault();
				}
			},

			_appendGhost: function () {
				if (!ghostEl) {
					var rect = dragEl.getBoundingClientRect(),
						css = _css(dragEl),
						options = this.options,
						ghostRect;

					ghostEl = dragEl.cloneNode(true);

					_toggleClass(ghostEl, options.ghostClass, false);
					_toggleClass(ghostEl, options.fallbackClass, true);
					_toggleClass(ghostEl, options.dragClass, true);

					_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
					_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
					_css(ghostEl, 'width', rect.width);
					_css(ghostEl, 'height', rect.height);
					_css(ghostEl, 'opacity', '0.8');
					_css(ghostEl, 'position', 'fixed');
					_css(ghostEl, 'zIndex', '100000');
					_css(ghostEl, 'pointerEvents', 'none');

					options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

					// Fixing dimensions.
					ghostRect = ghostEl.getBoundingClientRect();
					_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
					_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
				}
			},

			_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
				var _this = this;
				var dataTransfer = evt.dataTransfer;
				var options = _this.options;

				_this._offUpEvents();

				if (activeGroup.checkPull(_this, _this, dragEl, evt)) {
					cloneEl = _clone(dragEl);

					cloneEl.draggable = false;
					cloneEl.style['will-change'] = '';

					_css(cloneEl, 'display', 'none');
					_toggleClass(cloneEl, _this.options.chosenClass, false);

					// #1143: IFrame support workaround
					_this._cloneId = _nextTick(function () {
						rootEl.insertBefore(cloneEl, dragEl);
						_dispatchEvent(_this, rootEl, 'clone', dragEl);
					});
				}

				_toggleClass(dragEl, options.dragClass, true);

				if (useFallback) {
					if (useFallback === 'touch') {
						// Bind touch events
						_on(document, 'touchmove', _this._onTouchMove);
						_on(document, 'touchend', _this._onDrop);
						_on(document, 'touchcancel', _this._onDrop);

						if (options.supportPointer) {
							_on(document, 'pointermove', _this._onTouchMove);
							_on(document, 'pointerup', _this._onDrop);
						}
					} else {
						// Old brwoser
						_on(document, 'mousemove', _this._onTouchMove);
						_on(document, 'mouseup', _this._onDrop);
					}

					_this._loopId = setInterval(_this._emulateDragOver, 50);
				}
				else {
					if (dataTransfer) {
						dataTransfer.effectAllowed = 'move';
						options.setData && options.setData.call(_this, dataTransfer, dragEl);
					}

					_on(document, 'drop', _this);

					// #1143: Бывает элемент с IFrame внутри блокирует `drop`,
					// поэтому если вызвался `mouseover`, значит надо отменять весь d'n'd.
					// Breaking Chrome 62+
					// _on(document, 'mouseover', _this);

					_this._dragStartId = _nextTick(_this._dragStarted);
				}
			},

			_onDragOver: function (/**Event*/evt) {
				var el = this.el,
					target,
					dragRect,
					targetRect,
					revert,
					options = this.options,
					group = options.group,
					activeSortable = Sortable.active,
					isOwner = (activeGroup === group),
					isMovingBetweenSortable = false,
					canSort = options.sort;

				if (evt.preventDefault !== void 0) {
					evt.preventDefault();
					!options.dragoverBubble && evt.stopPropagation();
				}

				if (dragEl.animated) {
					return;
				}

				moved = true;

				if (activeSortable && !options.disabled &&
					(isOwner
						? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
						: (
							putSortable === this ||
							(
								(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
								group.checkPut(this, activeSortable, dragEl, evt)
							)
						)
					) &&
					(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
				) {
					// Smart auto-scrolling
					_autoScroll(evt, options, this.el);

					if (_silent) {
						return;
					}

					target = _closest(evt.target, options.draggable, el);
					dragRect = dragEl.getBoundingClientRect();

					if (putSortable !== this) {
						putSortable = this;
						isMovingBetweenSortable = true;
					}

					if (revert) {
						_cloneHide(activeSortable, true);
						parentEl = rootEl; // actualization

						if (cloneEl || nextEl) {
							rootEl.insertBefore(dragEl, cloneEl || nextEl);
						}
						else if (!canSort) {
							rootEl.appendChild(dragEl);
						}

						return;
					}


					if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
						(el === evt.target) && (_ghostIsLast(el, evt))
					) {
						//assign target only if condition is true
						if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
							target = el.lastElementChild;
						}

						if (target) {
							if (target.animated) {
								return;
							}

							targetRect = target.getBoundingClientRect();
						}

						_cloneHide(activeSortable, isOwner);

						if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
							if (!dragEl.contains(el)) {
								el.appendChild(dragEl);
								parentEl = el; // actualization
							}

							this._animate(dragRect, dragEl);
							target && this._animate(targetRect, target);
						}
					}
					else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
						if (lastEl !== target) {
							lastEl = target;
							lastCSS = _css(target);
							lastParentCSS = _css(target.parentNode);
						}

						targetRect = target.getBoundingClientRect();

						var width = targetRect.right - targetRect.left,
							height = targetRect.bottom - targetRect.top,
							floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)
								|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
							isWide = (target.offsetWidth > dragEl.offsetWidth),
							isLong = (target.offsetHeight > dragEl.offsetHeight),
							halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
							nextSibling = target.nextElementSibling,
							after = false
						;

						if (floating) {
							var elTop = dragEl.offsetTop,
								tgTop = target.offsetTop;

							if (elTop === tgTop) {
								after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
							}
							else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
								after = (evt.clientY - targetRect.top) / height > 0.5;
							} else {
								after = tgTop > elTop;
							}
							} else if (!isMovingBetweenSortable) {
							after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
						}

						var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

						if (moveVector !== false) {
							if (moveVector === 1 || moveVector === -1) {
								after = (moveVector === 1);
							}

							_silent = true;
							setTimeout(_unsilent, 30);

							_cloneHide(activeSortable, isOwner);

							if (!dragEl.contains(el)) {
								if (after && !nextSibling) {
									el.appendChild(dragEl);
								} else {
									target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
								}
							}

							parentEl = dragEl.parentNode; // actualization

							this._animate(dragRect, dragEl);
							this._animate(targetRect, target);
						}
					}
				}
			},

			_animate: function (prevRect, target) {
				var ms = this.options.animation;

				if (ms) {
					var currentRect = target.getBoundingClientRect();

					if (prevRect.nodeType === 1) {
						prevRect = prevRect.getBoundingClientRect();
					}

					_css(target, 'transition', 'none');
					_css(target, 'transform', 'translate3d('
						+ (prevRect.left - currentRect.left) + 'px,'
						+ (prevRect.top - currentRect.top) + 'px,0)'
					);

					target.offsetWidth; // repaint

					_css(target, 'transition', 'all ' + ms + 'ms');
					_css(target, 'transform', 'translate3d(0,0,0)');

					clearTimeout(target.animated);
					target.animated = setTimeout(function () {
						_css(target, 'transition', '');
						_css(target, 'transform', '');
						target.animated = false;
					}, ms);
				}
			},

			_offUpEvents: function () {
				var ownerDocument = this.el.ownerDocument;

				_off(document, 'touchmove', this._onTouchMove);
				_off(document, 'pointermove', this._onTouchMove);
				_off(ownerDocument, 'mouseup', this._onDrop);
				_off(ownerDocument, 'touchend', this._onDrop);
				_off(ownerDocument, 'pointerup', this._onDrop);
				_off(ownerDocument, 'touchcancel', this._onDrop);
				_off(ownerDocument, 'pointercancel', this._onDrop);
				_off(ownerDocument, 'selectstart', this);
			},

			_onDrop: function (/**Event*/evt) {
				var el = this.el,
					options = this.options;

				clearInterval(this._loopId);
				clearInterval(autoScroll.pid);
				clearTimeout(this._dragStartTimer);

				_cancelNextTick(this._cloneId);
				_cancelNextTick(this._dragStartId);

				// Unbind events
				_off(document, 'mouseover', this);
				_off(document, 'mousemove', this._onTouchMove);

				if (this.nativeDraggable) {
					_off(document, 'drop', this);
					_off(el, 'dragstart', this._onDragStart);
				}

				this._offUpEvents();

				if (evt) {
					if (moved) {
						evt.preventDefault();
						!options.dropBubble && evt.stopPropagation();
					}

					ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

					if (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {
						// Remove clone
						cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
					}

					if (dragEl) {
						if (this.nativeDraggable) {
							_off(dragEl, 'dragend', this);
						}

						_disableDraggable(dragEl);
						dragEl.style['will-change'] = '';

						// Remove class's
						_toggleClass(dragEl, this.options.ghostClass, false);
						_toggleClass(dragEl, this.options.chosenClass, false);

						// Drag stop event
						_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex);

						if (rootEl !== parentEl) {
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// Add event
								_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex);

								// Remove event
								_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex);

								// drag from one list and drop into another
								_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
								_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
							}
						}
						else {
							if (dragEl.nextSibling !== nextEl) {
								// Get the index of the dragged element within its parent
								newIndex = _index(dragEl, options.draggable);

								if (newIndex >= 0) {
									// drag & drop within the same list
									_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex);
									_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
								}
							}
						}

						if (Sortable.active) {
							/* jshint eqnull:true */
							if (newIndex == null || newIndex === -1) {
								newIndex = oldIndex;
							}

							_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex);

							// Save sorting
							this.save();
						}
					}

				}

				this._nulling();
			},

			_nulling: function() {
				rootEl =
				dragEl =
				parentEl =
				ghostEl =
				nextEl =
				cloneEl =
				lastDownEl =

				scrollEl =
				scrollParentEl =

				tapEvt =
				touchEvt =

				moved =
				newIndex =

				lastEl =
				lastCSS =

				putSortable =
				activeGroup =
				Sortable.active = null;

				savedInputChecked.forEach(function (el) {
					el.checked = true;
				});
				savedInputChecked.length = 0;
			},

			handleEvent: function (/**Event*/evt) {
				switch (evt.type) {
					case 'drop':
					case 'dragend':
						this._onDrop(evt);
						break;

					case 'dragover':
					case 'dragenter':
						if (dragEl) {
							this._onDragOver(evt);
							_globalDragOver(evt);
						}
						break;

					case 'mouseover':
						this._onDrop(evt);
						break;

					case 'selectstart':
						evt.preventDefault();
						break;
				}
			},


			/**
			 * Serializes the item into an array of string.
			 * @returns {String[]}
			 */
			toArray: function () {
				var this$1 = this;

				var order = [],
					el,
					children = this.el.children,
					i = 0,
					n = children.length,
					options = this.options;

				for (; i < n; i++) {
					el = children[i];
					if (_closest(el, options.draggable, this$1.el)) {
						order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
					}
				}

				return order;
			},


			/**
			 * Sorts the elements according to the array.
			 * @param  {String[]}  order  order of the items
			 */
			sort: function (order) {
				var items = {}, rootEl = this.el;

				this.toArray().forEach(function (id, i) {
					var el = rootEl.children[i];

					if (_closest(el, this.options.draggable, rootEl)) {
						items[id] = el;
					}
				}, this);

				order.forEach(function (id) {
					if (items[id]) {
						rootEl.removeChild(items[id]);
						rootEl.appendChild(items[id]);
					}
				});
			},


			/**
			 * Save the current sorting
			 */
			save: function () {
				var store = this.options.store;
				store && store.set(this);
			},


			/**
			 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
			 * @param   {HTMLElement}  el
			 * @param   {String}       [selector]  default: `options.draggable`
			 * @returns {HTMLElement|null}
			 */
			closest: function (el, selector) {
				return _closest(el, selector || this.options.draggable, this.el);
			},


			/**
			 * Set/get option
			 * @param   {string} name
			 * @param   {*}      [value]
			 * @returns {*}
			 */
			option: function (name, value) {
				var options = this.options;

				if (value === void 0) {
					return options[name];
				} else {
					options[name] = value;

					if (name === 'group') {
						_prepareGroup(options);
					}
				}
			},


			/**
			 * Destroy
			 */
			destroy: function () {
				var el = this.el;

				el[expando] = null;

				_off(el, 'mousedown', this._onTapStart);
				_off(el, 'touchstart', this._onTapStart);
				_off(el, 'pointerdown', this._onTapStart);

				if (this.nativeDraggable) {
					_off(el, 'dragover', this);
					_off(el, 'dragenter', this);
				}

				// Remove draggable attributes
				Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
					el.removeAttribute('draggable');
				});

				touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

				this._onDrop();

				this.el = el = null;
			}
		};


		function _cloneHide(sortable, state) {
			if (sortable.lastPullMode !== 'clone') {
				state = true;
			}

			if (cloneEl && (cloneEl.state !== state)) {
				_css(cloneEl, 'display', state ? 'none' : '');

				if (!state) {
					if (cloneEl.state) {
						if (sortable.options.group.revertClone) {
							rootEl.insertBefore(cloneEl, nextEl);
							sortable._animate(dragEl, cloneEl);
						} else {
							rootEl.insertBefore(cloneEl, dragEl);
						}
					}
				}

				cloneEl.state = state;
			}
		}


		function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
			if (el) {
				ctx = ctx || document;

				do {
					if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
						return el;
					}
					/* jshint boss:true */
				} while (el = _getParentOrHost(el));
			}

			return null;
		}


		function _getParentOrHost(el) {
			var parent = el.host;

			return (parent && parent.nodeType) ? parent : el.parentNode;
		}


		function _globalDragOver(/**Event*/evt) {
			if (evt.dataTransfer) {
				evt.dataTransfer.dropEffect = 'move';
			}
			evt.preventDefault();
		}


		function _on(el, event, fn) {
			el.addEventListener(event, fn, captureMode);
		}


		function _off(el, event, fn) {
			el.removeEventListener(event, fn, captureMode);
		}


		function _toggleClass(el, name, state) {
			if (el) {
				if (el.classList) {
					el.classList[state ? 'add' : 'remove'](name);
				}
				else {
					var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
					el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
				}
			}
		}


		function _css(el, prop, val) {
			var style = el && el.style;

			if (style) {
				if (val === void 0) {
					if (document.defaultView && document.defaultView.getComputedStyle) {
						val = document.defaultView.getComputedStyle(el, '');
					}
					else if (el.currentStyle) {
						val = el.currentStyle;
					}

					return prop === void 0 ? val : val[prop];
				}
				else {
					if (!(prop in style)) {
						prop = '-webkit-' + prop;
					}

					style[prop] = val + (typeof val === 'string' ? '' : 'px');
				}
			}
		}


		function _find(ctx, tagName, iterator) {
			if (ctx) {
				var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

				if (iterator) {
					for (; i < n; i++) {
						iterator(list[i], i);
					}
				}

				return list;
			}

			return [];
		}



		function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex) {
			sortable = (sortable || rootEl[expando]);

			var evt = document.createEvent('Event'),
				options = sortable.options,
				onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

			evt.initEvent(name, true, true);

			evt.to = toEl || rootEl;
			evt.from = fromEl || rootEl;
			evt.item = targetEl || rootEl;
			evt.clone = cloneEl;

			evt.oldIndex = startIndex;
			evt.newIndex = newIndex;

			rootEl.dispatchEvent(evt);

			if (options[onName]) {
				options[onName].call(sortable, evt);
			}
		}


		function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
			var evt,
				sortable = fromEl[expando],
				onMoveFn = sortable.options.onMove,
				retVal;

			evt = document.createEvent('Event');
			evt.initEvent('move', true, true);

			evt.to = toEl;
			evt.from = fromEl;
			evt.dragged = dragEl;
			evt.draggedRect = dragRect;
			evt.related = targetEl || toEl;
			evt.relatedRect = targetRect || toEl.getBoundingClientRect();
			evt.willInsertAfter = willInsertAfter;

			fromEl.dispatchEvent(evt);

			if (onMoveFn) {
				retVal = onMoveFn.call(sortable, evt, originalEvt);
			}

			return retVal;
		}


		function _disableDraggable(el) {
			el.draggable = false;
		}


		function _unsilent() {
			_silent = false;
		}


		/** @returns {HTMLElement|false} */
		function _ghostIsLast(el, evt) {
			var lastEl = el.lastElementChild,
				rect = lastEl.getBoundingClientRect();

			// 5 — min delta
			// abs — нельзя добавлять, а то глюки при наведении сверху
			return (evt.clientY - (rect.top + rect.height) > 5) ||
				(evt.clientX - (rect.left + rect.width) > 5);
		}


		/**
		 * Generate id
		 * @param   {HTMLElement} el
		 * @returns {String}
		 * @private
		 */
		function _generateId(el) {
			var str = el.tagName + el.className + el.src + el.href + el.textContent,
				i = str.length,
				sum = 0;

			while (i--) {
				sum += str.charCodeAt(i);
			}

			return sum.toString(36);
		}

		/**
		 * Returns the index of an element within its parent for a selected set of
		 * elements
		 * @param  {HTMLElement} el
		 * @param  {selector} selector
		 * @return {number}
		 */
		function _index(el, selector) {
			var index = 0;

			if (!el || !el.parentNode) {
				return -1;
			}

			while (el && (el = el.previousElementSibling)) {
				if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
					index++;
				}
			}

			return index;
		}

		function _matches(/**HTMLElement*/el, /**String*/selector) {
			if (el) {
				selector = selector.split('.');

				var tag = selector.shift().toUpperCase(),
					re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

				return (
					(tag === '' || el.nodeName.toUpperCase() == tag) &&
					(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
				);
			}

			return false;
		}

		function _throttle(callback, ms) {
			var args, _this;

			return function () {
				if (args === void 0) {
					args = arguments;
					_this = this;

					setTimeout(function () {
						if (args.length === 1) {
							callback.call(_this, args[0]);
						} else {
							callback.apply(_this, args);
						}

						args = void 0;
					}, ms);
				}
			};
		}

		function _extend(dst, src) {
			if (dst && src) {
				for (var key in src) {
					if (src.hasOwnProperty(key)) {
						dst[key] = src[key];
					}
				}
			}

			return dst;
		}

		function _clone(el) {
			if (Polymer && Polymer.dom) {
				return Polymer.dom(el).cloneNode(true);
			}
			else if ($) {
				return $(el).clone(true)[0];
			}
			else {
				return el.cloneNode(true);
			}
		}

		function _saveInputCheckedState(root) {
			var inputs = root.getElementsByTagName('input');
			var idx = inputs.length;

			while (idx--) {
				var el = inputs[idx];
				el.checked && savedInputChecked.push(el);
			}
		}

		function _nextTick(fn) {
			return setTimeout(fn, 0);
		}

		function _cancelNextTick(id) {
			return clearTimeout(id);
		}

		// Fixed #973:
		_on(document, 'touchmove', function (evt) {
			if (Sortable.active) {
				evt.preventDefault();
			}
		});

		// Export utils
		Sortable.utils = {
			on: _on,
			off: _off,
			css: _css,
			find: _find,
			is: function (el, selector) {
				return !!_closest(el, selector, el);
			},
			extend: _extend,
			throttle: _throttle,
			closest: _closest,
			toggleClass: _toggleClass,
			clone: _clone,
			index: _index,
			nextTick: _nextTick,
			cancelNextTick: _cancelNextTick
		};


		/**
		 * Create sortable instance
		 * @param {HTMLElement}  el
		 * @param {Object}      [options]
		 */
		Sortable.create = function (el, options) {
			return new Sortable(el, options);
		};


		// Export
		Sortable.version = '1.7.0';
		return Sortable;
	});
	});

	var frappeDatatable_cjs = createCommonjsModule(function (module) {

	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var Sortable$$1 = _interopDefault(Sortable);

	function $(expr, con) {
	    return typeof expr === 'string' ?
	        (con || document).querySelector(expr) :
	        expr || null;
	}

	$.each = function (expr, con) {
	    return typeof expr === 'string' ?
	        Array.from((con || document).querySelectorAll(expr)) :
	        expr || null;
	};

	$.create = function (tag, o) {
	    var element = document.createElement(tag);

	    var loop = function ( i ) {
	        var val = o[i];

	        if (i === 'inside') {
	            $(val).appendChild(element);
	        } else
	        if (i === 'around') {
	            var ref = $(val);
	            ref.parentNode.insertBefore(element, ref);
	            element.appendChild(ref);
	        } else
	        if (i === 'styles') {
	            if (typeof val === 'object') {
	                Object.keys(val).map(function (prop) {
	                    element.style[prop] = val[prop];
	                });
	            }
	        } else
	        if (i in element) {
	            element[i] = val;
	        } else {
	            element.setAttribute(i, val);
	        }
	    };

	    for (var i in o) loop( i );

	    return element;
	};

	$.on = function (element, event, selector, callback) {
	    if (!callback) {
	        callback = selector;
	        $.bind(element, event, callback);
	    } else {
	        $.delegate(element, event, selector, callback);
	    }
	};

	$.off = function (element, event, handler) {
	    element.removeEventListener(event, handler);
	};

	$.bind = function (element, event, callback) {
	    event.split(/\s+/).forEach(function (event) {
	        element.addEventListener(event, callback);
	    });
	};

	$.delegate = function (element, event, selector, callback) {
	    element.addEventListener(event, function (e) {
	        var delegatedTarget = e.target.closest(selector);
	        if (delegatedTarget) {
	            e.delegatedTarget = delegatedTarget;
	            callback.call(this, e, delegatedTarget);
	        }
	    });
	};

	$.unbind = function (element, o) {
	    if (element) {
	        var loop = function ( event ) {
	            var callback = o[event];

	            event.split(/\s+/).forEach(function (event) {
	                element.removeEventListener(event, callback);
	            });
	        };

	        for (var event in o) loop( event );
	    }
	};

	$.fire = function (target, type, properties) {
	    var evt = document.createEvent('HTMLEvents');

	    evt.initEvent(type, true, true);

	    for (var j in properties) {
	        evt[j] = properties[j];
	    }

	    return target.dispatchEvent(evt);
	};

	$.data = function (element, attrs) { // eslint-disable-line
	    if (!attrs) {
	        return element.dataset;
	    }

	    for (var attr in attrs) {
	        element.dataset[attr] = attrs[attr];
	    }
	};

	$.style = function (elements, styleMap) { // eslint-disable-line

	    if (typeof styleMap === 'string') {
	        return $.getStyle(elements, styleMap);
	    }

	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    elements.map(function (element) {
	        for (var prop in styleMap) {
	            element.style[prop] = styleMap[prop];
	        }
	    });
	};

	$.removeStyle = function (elements, styleProps) {
	    if (!Array.isArray(elements)) {
	        elements = [elements];
	    }

	    if (!Array.isArray(styleProps)) {
	        styleProps = [styleProps];
	    }

	    elements.map(function (element) {
	        for (var i = 0, list = styleProps; i < list.length; i += 1) {
	            var prop = list[i];

	          element.style[prop] = '';
	        }
	    });
	};

	$.getStyle = function (element, prop) {
	    var val = getComputedStyle(element)[prop];

	    if (['width', 'height'].includes(prop)) {
	        val = parseFloat(val);
	    }

	    return val;
	};

	$.closest = function (selector, element) {
	    if (!element) { return null; }

	    if (element.matches(selector)) {
	        return element;
	    }

	    return $.closest(selector, element.parentNode);
	};

	$.inViewport = function (el, parentEl) {
	    var ref = el.getBoundingClientRect();
	    var top = ref.top;
	    var left = ref.left;
	    var bottom = ref.bottom;
	    var right = ref.right;
	    var ref$1 = parentEl.getBoundingClientRect();
	    var pTop = ref$1.top;
	    var pLeft = ref$1.left;
	    var pBottom = ref$1.bottom;
	    var pRight = ref$1.right;

	    return top >= pTop && left >= pLeft && bottom <= pBottom && right <= pRight;
	};

	$.scrollTop = function scrollTop(element, pixels) {
	    requestAnimationFrame(function () {
	        element.scrollTop = pixels;
	    });
	};

	$.scrollbarSize = function scrollbarSize() {
	    if (!$.scrollBarSizeValue) {
	        $.scrollBarSizeValue = getScrollBarSize();
	    }
	    return $.scrollBarSizeValue;
	};

	function getScrollBarSize() {
	    // assume scrollbar width and height would be the same

	    // Create the measurement node
	    var scrollDiv = document.createElement('div');
	    $.style(scrollDiv, {
	        width: '100px',
	        height: '100px',
	        overflow: 'scroll',
	        position: 'absolute',
	        top: '-9999px'
	    });
	    document.body.appendChild(scrollDiv);

	    // Get the scrollbar width
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

	    // Delete the DIV
	    document.body.removeChild(scrollDiv);

	    return scrollbarWidth;
	}

	$.hasVerticalOverflow = function (element) {
	    return element.scrollHeight > element.offsetHeight + 10;
	};

	$.hasHorizontalOverflow = function (element) {
	    return element.scrollWidth > element.offsetWidth + 10;
	};

	$.measureTextWidth = function (text) {
	    var div = document.createElement('div');
	    div.style.position = 'absolute';
	    div.style.visibility = 'hidden';
	    div.style.height = 'auto';
	    div.style.width = 'auto';
	    div.style.whiteSpace = 'nowrap';
	    div.innerText = text;
	    document.body.appendChild(div);
	    return div.clientWidth + 1;
	};

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

	function commonjsRequire$$1 () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports$$1 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule$$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal$$1 == 'object' && commonjsGlobal$$1 && commonjsGlobal$$1.Object === Object && commonjsGlobal$$1;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return _root.Date.now();
	};

	var now_1 = now;

	/** Built-in value references. */
	var Symbol = _root.Symbol;

	var _Symbol = Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
	}

	var isSymbol_1 = isSymbol;

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol_1(value)) {
	    return NAN;
	  }
	  if (isObject_1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject_1(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var toNumber_1 = toNumber;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber_1(wait) || 0;
	  if (isObject_1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now_1();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now_1());
	  }

	  function debounced() {
	    var time = now_1(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	var debounce_1 = debounce;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  if (isObject_1(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce_1(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	var throttle_1 = throttle;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var this$1 = this;

	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this$1.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var this$1 = this;

	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this$1.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var this$1 = this;

	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this$1.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var this$1 = this;

	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this$1.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _baseFindIndex = baseFindIndex;

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	var _baseIsNaN = baseIsNaN;

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _strictIndexOf = strictIndexOf;

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? _strictIndexOf(array, value, fromIndex)
	    : _baseFindIndex(array, _baseIsNaN, fromIndex);
	}

	var _baseIndexOf = baseIndexOf;

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && _baseIndexOf(array, value, 0) > -1;
	}

	var _arrayIncludes = arrayIncludes;

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arrayIncludesWith = arrayIncludesWith;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/* Built-in method references that are verified to be native. */
	var Set = _getNative(_root, 'Set');

	var _Set = Set;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	var noop_1 = noop;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(_Set && (1 / _setToArray(new _Set([,-0]))[1]) == INFINITY) ? noop_1 : function(values) {
	  return new _Set(values);
	};

	var _createSet = createSet;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = _arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = _arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : _createSet(array);
	    if (set) {
	      return _setToArray(set);
	    }
	    isCommon = false;
	    includes = _cacheHas;
	    seen = new _SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	var _baseUniq = baseUniq;

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? _baseUniq(array) : [];
	}

	var uniq_1 = uniq;

	function camelCaseToDash(str) {
	    return str.replace(/([A-Z])/g, function (g) { return ("-" + (g[0].toLowerCase())); });
	}

	function makeDataAttributeString(props) {
	    var keys = Object.keys(props);

	    return keys
	        .map(function (key) {
	            var _key = camelCaseToDash(key);
	            var val = props[key];

	            if (val === undefined) { return ''; }
	            return ("data-" + _key + "=\"" + val + "\" ");
	        })
	        .join('')
	        .trim();
	}

	function copyTextToClipboard(text) {
	    // https://stackoverflow.com/a/30810322/5353542
	    var textArea = document.createElement('textarea');

	    //
	    // *** This styling is an extra step which is likely not required. ***
	    //
	    // Why is it here? To ensure:
	    // 1. the element is able to have focus and selection.
	    // 2. if element was to flash render it has minimal visual impact.
	    // 3. less flakyness with selection and copying which **might** occur if
	    //    the textarea element is not visible.
	    //
	    // The likelihood is the element won't even render, not even a flash,
	    // so some of these are just precautions. However in IE the element
	    // is visible whilst the popup box asking the user for permission for
	    // the web page to copy to the clipboard.
	    //

	    // Place in top-left corner of screen regardless of scroll position.
	    textArea.style.position = 'fixed';
	    textArea.style.top = 0;
	    textArea.style.left = 0;

	    // Ensure it has a small width and height. Setting to 1px / 1em
	    // doesn't work as this gives a negative w/h on some browsers.
	    textArea.style.width = '2em';
	    textArea.style.height = '2em';

	    // We don't need padding, reducing the size if it does flash render.
	    textArea.style.padding = 0;

	    // Clean up any borders.
	    textArea.style.border = 'none';
	    textArea.style.outline = 'none';
	    textArea.style.boxShadow = 'none';

	    // Avoid flash of white box if rendered for any reason.
	    textArea.style.background = 'transparent';

	    textArea.value = text;

	    document.body.appendChild(textArea);

	    textArea.select();

	    try {
	        document.execCommand('copy');
	    } catch (err) {
	        console.log('Oops, unable to copy');
	    }

	    document.body.removeChild(textArea);
	}

	function isNumeric(val) {
	    return !isNaN(val);
	}

	var throttle$1 = throttle_1;

	var debounce$1 = debounce_1;

	function nextTick(fn, context) {
	    if ( context === void 0 ) context = null;

	    return function () {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new Promise(function (resolve) {
	            var execute = function () {
	                var out = fn.apply(context, args);
	                resolve(out);
	            };
	            setTimeout(execute);
	        });
	    };
	}
	function linkProperties(target, source, properties) {
	    var props = properties.reduce(function (acc, prop) {
	        acc[prop] = {
	            get: function get() {
	                return source[prop];
	            }
	        };
	        return acc;
	    }, {});
	    Object.defineProperties(target, props);
	}
	function isSet(val) {
	    return val !== undefined || val !== null;
	}

	function notSet(val) {
	    return !isSet(val);
	}

	function isNumber(val) {
	    return !isNaN(val);
	}

	function ensureArray(val) {
	    if (!Array.isArray(val)) {
	        return [val];
	    }
	    return val;
	}

	function uniq$1(arr) {
	    return uniq_1(arr);
	}

	function numberSortAsc(a, b) {
	    return a - b;
	}
	function stripHTML(html) {
	    return html.replace(/<[^>]*>/g, '');
	}

	class DataManager {
	    constructor(options) {
	        this.options = options;
	        this.sortRows = nextTick(this.sortRows, this);
	        this.switchColumn = nextTick(this.switchColumn, this);
	        this.removeColumn = nextTick(this.removeColumn, this);
	        this.options.filterRows = nextTick(this.options.filterRows, this);
	    }

	    init(data, columns) {
	        if (!data) {
	            data = this.options.data;
	        }
	        if (columns) {
	            this.options.columns = columns;
	        }

	        this.data = data;

	        this.rowCount = 0;
	        this.columns = [];
	        this.rows = [];

	        this.prepareColumns();
	        this.prepareRows();
	        this.prepareTreeRows();
	        this.prepareRowView();
	        this.prepareNumericColumns();
	    }

	    // computed property
	    get currentSort() {
	        var col = this.columns.find(function (col) { return col.sortOrder !== 'none'; });
	        return col || {
	            colIndex: -1,
	            sortOrder: 'none'
	        };
	    }

	    prepareColumns() {
	        this.columns = [];
	        this.validateColumns();
	        this.prepareDefaultColumns();
	        this.prepareHeader();
	    }

	    prepareDefaultColumns() {
	        if (this.options.checkboxColumn && !this.hasColumnById('_checkbox')) {
	            var cell = {
	                id: '_checkbox',
	                content: this.getCheckboxHTML(),
	                editable: false,
	                resizable: false,
	                sortable: false,
	                focusable: false,
	                dropdown: false,
	                width: 32
	            };
	            this.columns.push(cell);
	        }

	        if (this.options.serialNoColumn && !this.hasColumnById('_rowIndex')) {
	            var cell$1 = {
	                id: '_rowIndex',
	                content: '',
	                align: 'center',
	                editable: false,
	                resizable: false,
	                focusable: false,
	                dropdown: false
	            };

	            this.columns.push(cell$1);
	        }
	    }

	    prepareHeader() {
	        var this$1 = this;

	        var columns = this.columns.concat(this.options.columns);
	        var baseCell = {
	            isHeader: 1,
	            editable: true,
	            sortable: true,
	            resizable: true,
	            focusable: true,
	            dropdown: true,
	            width: null,
	            format: function (value) {
	                if (value === null || value === undefined) {
	                    return '';
	                }
	                return value + '';
	            }
	        };

	        this.columns = columns
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (col) { return Object.assign({}, baseCell, col); })
	            .map(function (col) {
	                col.content = col.content || col.name || '';
	                col.id = col.id || col.content;
	                return col;
	            });
	    }

	    prepareCell(content, i) {
	        var cell = {
	            content: '',
	            sortOrder: 'none',
	            colIndex: i,
	            column: this.columns[i]
	        };

	        if (content !== null && typeof content === 'object') {
	            // passed as column/header
	            Object.assign(cell, content);
	        } else {
	            cell.content = content;
	        }

	        return cell;
	    }

	    prepareNumericColumns() {
	        var row0 = this.getRow(0);
	        if (!row0) { return; }
	        this.columns = this.columns.map(function (column, i) {

	            var cellValue = row0[i].content;
	            if (!column.align && isNumeric(cellValue)) {
	                column.align = 'right';
	            }

	            return column;
	        });
	    }

	    prepareRows() {
	        var this$1 = this;

	        this.validateData(this.data);

	        this.rows = this.data.map(function (d, i) {
	            var index = this$1._getNextRowCount();

	            var row = [];
	            var meta = {
	                rowIndex: index
	            };

	            if (Array.isArray(d)) {
	                // row is an array
	                if (this$1.options.checkboxColumn) {
	                    row.push(this$1.getCheckboxHTML());
	                }
	                if (this$1.options.serialNoColumn) {
	                    row.push((index + 1) + '');
	                }
	                row = row.concat(d);

	                while (row.length < this$1.columns.length) {
	                    row.push('');
	                }

	            } else {
	                // row is an object
	                for (var i$1 = 0, list = this$1.columns; i$1 < list.length; i$1 += 1) {
	                    var col = list[i$1];

	                  if (col.id === '_checkbox') {
	                        row.push(this$1.getCheckboxHTML());
	                    } else if (col.id === '_rowIndex') {
	                        row.push((index + 1) + '');
	                    } else {
	                        row.push(d[col.id]);
	                    }
	                }

	                meta.indent = d.indent || 0;
	            }

	            return this$1.prepareRow(row, meta);
	        });
	    }

	    prepareTreeRows() {
	        var this$1 = this;

	        this.rows.forEach(function (row, i) {
	            if (isNumber(row.meta.indent)) {
	                // if (i === 36) debugger;
	                var nextRow = this$1.getRow(i + 1);
	                row.meta.isLeaf = !nextRow ||
	                    notSet(nextRow.meta.indent) ||
	                    nextRow.meta.indent <= row.meta.indent;
	                row.meta.isTreeNodeClose = false;
	            }
	        });
	    }

	    prepareRowView() {
	        // This is order in which rows will be rendered in the table.
	        // When sorting happens, only this.rowViewOrder will change
	        // and not the original this.rows
	        this.rowViewOrder = this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    prepareRow(row, meta) {
	        var this$1 = this;

	        var baseRowCell = {
	            rowIndex: meta.rowIndex,
	            indent: meta.indent
	        };

	        row = row
	            .map(function (cell, i) { return this$1.prepareCell(cell, i); })
	            .map(function (cell) { return Object.assign({}, baseRowCell, cell); });

	        // monkey patched in array object
	        row.meta = meta;
	        return row;
	    }

	    validateColumns() {
	        var columns = this.options.columns;
	        if (!Array.isArray(columns)) {
	            throw new DataError('`columns` must be an array');
	        }

	        columns.forEach(function (column, i) {
	            if (typeof column !== 'string' && typeof column !== 'object') {
	                throw new DataError(("column \"" + i + "\" must be a string or an object"));
	            }
	        });
	    }

	    validateData(data) {
	        if (Array.isArray(data) &&
	            (data.length === 0 || Array.isArray(data[0]) || typeof data[0] === 'object')) {
	            return true;
	        }
	        throw new DataError('`data` must be an array of arrays or objects');
	    }

	    appendRows(rows) {
	        var ref;

	        this.validateData(rows);

	        (ref = this.rows).push.apply(ref, this.prepareRows(rows));
	    }

	    sortRows(colIndex, sortOrder) {
	        if ( sortOrder === void 0 ) sortOrder = 'none';

	        colIndex = +colIndex;

	        // reset sortOrder and update for colIndex
	        this.getColumns()
	            .map(function (col) {
	                if (col.colIndex === colIndex) {
	                    col.sortOrder = sortOrder;
	                } else {
	                    col.sortOrder = 'none';
	                }
	            });

	        this._sortRows(colIndex, sortOrder);
	    }

	    _sortRows(colIndex, sortOrder) {
	        var this$1 = this;


	        if (this.currentSort.colIndex === colIndex) {
	            // reverse the array if only sortOrder changed
	            if (
	                (this.currentSort.sortOrder === 'asc' && sortOrder === 'desc') ||
	                (this.currentSort.sortOrder === 'desc' && sortOrder === 'asc')
	            ) {
	                this.reverseArray(this.rowViewOrder);
	                this.currentSort.sortOrder = sortOrder;
	                return;
	            }
	        }

	        this.rowViewOrder.sort(function (a, b) {
	            var aIndex = a;
	            var bIndex = b;
	            var aContent = this$1.getCell(colIndex, a).content;
	            var bContent = this$1.getCell(colIndex, b).content;

	            if (sortOrder === 'none') {
	                return aIndex - bIndex;
	            } else if (sortOrder === 'asc') {
	                if (aContent < bContent) { return -1; }
	                if (aContent > bContent) { return 1; }
	                if (aContent === bContent) { return 0; }
	            } else if (sortOrder === 'desc') {
	                if (aContent < bContent) { return 1; }
	                if (aContent > bContent) { return -1; }
	                if (aContent === bContent) { return 0; }
	            }
	            return 0;
	        });

	        if (this.hasColumnById('_rowIndex')) {
	            // update row index
	            var srNoColIndex = this.getColumnIndexById('_rowIndex');
	            this.rows.forEach(function (row, index) {
	                var viewIndex = this$1.rowViewOrder.indexOf(index);
	                var cell = row[srNoColIndex];
	                cell.content = (viewIndex + 1) + '';
	            });
	        }
	    }

	    reverseArray(array) {
	        var left = null;
	        var right = null;
	        var length = array.length;

	        for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
	            var temporary = array[left];

	            array[left] = array[right];
	            array[right] = temporary;
	        }
	    }

	    switchColumn(index1, index2) {
	        // update columns
	        var temp = this.columns[index1];
	        this.columns[index1] = this.columns[index2];
	        this.columns[index2] = temp;

	        this.columns[index1].colIndex = index1;
	        this.columns[index2].colIndex = index2;

	        // update rows
	        this.rows.forEach(function (row) {
	            var newCell1 = Object.assign({}, row[index1], {
	                colIndex: index2
	            });
	            var newCell2 = Object.assign({}, row[index2], {
	                colIndex: index1
	            });

	            row[index2] = newCell1;
	            row[index1] = newCell2;
	        });
	    }

	    removeColumn(index) {
	        index = +index;
	        var filter = function (cell) { return cell.colIndex !== index; };
	        var map = function (cell, i) { return Object.assign({}, cell, {
	            colIndex: i
	        }); };
	        // update columns
	        this.columns = this.columns
	            .filter(filter)
	            .map(map);

	        // update rows
	        this.rows.forEach(function (row) {
	            // remove cell
	            row.splice(index, 1);
	            // update colIndex
	            row.forEach(function (cell, i) {
	                cell.colIndex = i;
	            });
	        });
	    }

	    updateRow(row, rowIndex) {
	        if (row.length < this.columns.length) {
	            if (this.hasColumnById('_rowIndex')) {
	                var val = (rowIndex + 1) + '';

	                row = [val].concat(row);
	            }

	            if (this.hasColumnById('_checkbox')) {
	                var val$1 = '<input type="checkbox" />';

	                row = [val$1].concat(row);
	            }
	        }

	        var _row = this.prepareRow(row, {rowIndex: rowIndex});
	        var index = this.rows.findIndex(function (row) { return row[0].rowIndex === rowIndex; });
	        this.rows[index] = _row;

	        return _row;
	    }

	    updateCell(colIndex, rowIndex, options) {
	        var cell;
	        if (typeof colIndex === 'object') {
	            // cell object was passed,
	            // must have colIndex, rowIndex
	            cell = colIndex;
	            colIndex = cell.colIndex;
	            rowIndex = cell.rowIndex;
	            // the object passed must be merged with original cell
	            options = cell;
	        }
	        cell = this.getCell(colIndex, rowIndex);

	        // mutate object directly
	        for (var key in options) {
	            var newVal = options[key];
	            if (newVal !== undefined) {
	                cell[key] = newVal;
	            }
	        }

	        return cell;
	    }

	    updateColumn(colIndex, keyValPairs) {
	        var column = this.getColumn(colIndex);
	        for (var key in keyValPairs) {
	            var newVal = keyValPairs[key];
	            if (newVal !== undefined) {
	                column[key] = newVal;
	            }
	        }
	        return column;
	    }

	    filterRows(filters) {
	        var this$1 = this;

	        return this.options.filterRows(this.rows, filters)
	            .then(function (result) {
	                if (!result) {
	                    result = this$1.getAllRowIndices();
	                }

	                if (!result.then) {
	                    result = Promise.resolve(result);
	                }

	                return result.then(function (rowsToShow) {
	                    this$1._filteredRows = rowsToShow;

	                    var rowsToHide = this$1.getAllRowIndices()
	                        .filter(function (index) { return !rowsToShow.includes(index); });

	                    return {
	                        rowsToHide: rowsToHide,
	                        rowsToShow: rowsToShow
	                    };
	                });
	            });
	    }

	    getFilteredRowIndices() {
	        return this._filteredRows || this.getAllRowIndices();
	    }

	    getAllRowIndices() {
	        return this.rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    getRowCount() {
	        return this.rowCount;
	    }

	    _getNextRowCount() {
	        var val = this.rowCount;

	        this.rowCount++;
	        return val;
	    }

	    getRows(start, end) {
	        return this.rows.slice(start, end);
	    }

	    getRowsForView(start, end) {
	        var this$1 = this;

	        var rows = this.rowViewOrder.map(function (i) { return this$1.rows[i]; });
	        return rows.slice(start, end);
	    }

	    getColumns(skipStandardColumns) {
	        var columns = this.columns;

	        if (skipStandardColumns) {
	            columns = columns.slice(this.getStandardColumnCount());
	        }

	        return columns;
	    }

	    getStandardColumnCount() {
	        if (this.options.checkboxColumn && this.options.serialNoColumn) {
	            return 2;
	        }

	        if (this.options.checkboxColumn || this.options.serialNoColumn) {
	            return 1;
	        }

	        return 0;
	    }

	    getColumnCount(skipStandardColumns) {
	        var val = this.columns.length;

	        if (skipStandardColumns) {
	            val = val - this.getStandardColumnCount();
	        }

	        return val;
	    }

	    getColumn(colIndex) {
	        colIndex = +colIndex;

	        if (colIndex < 0) {
	            // negative indexes
	            colIndex = this.columns.length + colIndex;
	        }

	        return this.columns.find(function (col) { return col.colIndex === colIndex; });
	    }

	    getColumnById(id) {
	        return this.columns.find(function (col) { return col.id === id; });
	    }

	    getRow(rowIndex) {
	        rowIndex = +rowIndex;
	        return this.rows[rowIndex];
	    }

	    getCell(colIndex, rowIndex) {
	        rowIndex = +rowIndex;
	        colIndex = +colIndex;
	        return this.getRow(rowIndex)[colIndex];
	    }

	    getChildren(parentRowIndex) {
	        var this$1 = this;

	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this$1.getRow(i);
	            if (isNaN(row.meta.indent)) { continue; }

	            if (row.meta.indent > parentIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    getImmediateChildren(parentRowIndex) {
	        var this$1 = this;

	        parentRowIndex = +parentRowIndex;
	        var parentIndent = this.getRow(parentRowIndex).meta.indent;
	        var out = [];
	        var childIndent = parentIndent + 1;

	        for (var i = parentRowIndex + 1; i < this.rowCount; i++) {
	            var row = this$1.getRow(i);
	            if (isNaN(row.meta.indent) || row.meta.indent > childIndent) { continue; }

	            if (row.meta.indent === childIndent) {
	                out.push(i);
	            }

	            if (row.meta.indent === parentIndent) {
	                break;
	            }
	        }

	        return out;
	    }

	    get() {
	        return {
	            columns: this.columns,
	            rows: this.rows
	        };
	    }

	    /**
	     * Returns the original data which was passed
	     * based on rowIndex
	     * @param {Number} rowIndex
	     * @returns Array|Object
	     * @memberof DataManager
	     */
	    getData(rowIndex) {
	        return this.data[rowIndex];
	    }

	    hasColumn(name) {
	        return Boolean(this.columns.find(function (col) { return col.content === name; }));
	    }

	    hasColumnById(id) {
	        return Boolean(this.columns.find(function (col) { return col.id === id; }));
	    }

	    getColumnIndex(name) {
	        return this.columns.findIndex(function (col) { return col.content === name; });
	    }

	    getColumnIndexById(id) {
	        return this.columns.findIndex(function (col) { return col.id === id; });
	    }

	    getCheckboxHTML() {
	        return '<input type="checkbox" />';
	    }
	}

	// Custom Errors
	class DataError extends TypeError {}

	/* eslint-disable max-len */

	// Icons from https://feathericons.com/

	var icons = {
	    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
	    chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>'
	};

	class CellManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'wrapper',
	            'options',
	            'style',
	            'header',
	            'bodyScrollable',
	            'columnmanager',
	            'rowmanager',
	            'datamanager',
	            'keyboard'
	        ]);

	        this.bindEvents();
	    }

	    bindEvents() {
	        this.bindFocusCell();
	        this.bindEditCell();
	        this.bindKeyboardSelection();
	        this.bindCopyCellContents();
	        this.bindMouseEvents();
	        this.bindTreeEvents();
	    }

	    bindFocusCell() {
	        this.bindKeyboardNav();
	    }

	    bindEditCell() {
	        var this$1 = this;

	        this.$editingCell = null;

	        $.on(this.bodyScrollable, 'dblclick', '.dt-cell', function (e, cell) {
	            this$1.activateEditing(cell);
	        });

	        this.keyboard.on('enter', function () {
	            if (this$1.$focusedCell && !this$1.$editingCell) {
	                // enter keypress on focused cell
	                this$1.activateEditing(this$1.$focusedCell);
	            } else if (this$1.$editingCell) {
	                // enter keypress on editing cell
	                this$1.submitEditing();
	                this$1.deactivateEditing();
	            }
	        });
	    }

	    bindKeyboardNav() {
	        var this$1 = this;

	        var focusCell = function (direction) {
	            if (!this$1.$focusedCell || this$1.$editingCell) {
	                return false;
	            }

	            var $cell = this$1.$focusedCell;

	            if (direction === 'left' || direction === 'shift+tab') {
	                $cell = this$1.getLeftCell$($cell);
	            } else if (direction === 'right' || direction === 'tab') {
	                $cell = this$1.getRightCell$($cell);
	            } else if (direction === 'up') {
	                $cell = this$1.getAboveCell$($cell);
	            } else if (direction === 'down') {
	                $cell = this$1.getBelowCell$($cell);
	            }

	            this$1.focusCell($cell);
	            return true;
	        };

	        var focusLastCell = function (direction) {
	            if (!this$1.$focusedCell || this$1.$editingCell) {
	                return false;
	            }

	            var $cell = this$1.$focusedCell;
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var colIndex = ref.colIndex;

	            if (direction === 'left') {
	                $cell = this$1.getLeftMostCell$(rowIndex);
	            } else if (direction === 'right') {
	                $cell = this$1.getRightMostCell$(rowIndex);
	            } else if (direction === 'up') {
	                $cell = this$1.getTopMostCell$(colIndex);
	            } else if (direction === 'down') {
	                $cell = this$1.getBottomMostCell$(colIndex);
	            }

	            this$1.focusCell($cell);
	            return true;
	        };

	        ['left', 'right', 'up', 'down', 'tab', 'shift+tab']
	            .map(function (direction) { return this$1.keyboard.on(direction, function () { return focusCell(direction); }); });

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("ctrl+" + direction), function () { return focusLastCell(direction); }); });

	        this.keyboard.on('esc', function () {
	            this$1.deactivateEditing();
	            this$1.columnmanager.toggleFilter(false);
	        });

	        if (this.options.inlineFilters) {
	            this.keyboard.on('ctrl+f', function (e) {
	                var $cell = $.closest('.dt-cell', e.target);
	                var ref = $.data($cell);
	                var colIndex = ref.colIndex;

	                this$1.activateFilter(colIndex);
	                return true;
	            });

	            $.on(this.header, 'focusin', '.dt-filter', function () {
	                this$1.unfocusCell(this$1.$focusedCell);
	            });
	        }
	    }

	    bindKeyboardSelection() {
	        var this$1 = this;

	        var getNextSelectionCursor = function (direction) {
	            var $selectionCursor = this$1.getSelectionCursor();

	            if (direction === 'left') {
	                $selectionCursor = this$1.getLeftCell$($selectionCursor);
	            } else if (direction === 'right') {
	                $selectionCursor = this$1.getRightCell$($selectionCursor);
	            } else if (direction === 'up') {
	                $selectionCursor = this$1.getAboveCell$($selectionCursor);
	            } else if (direction === 'down') {
	                $selectionCursor = this$1.getBelowCell$($selectionCursor);
	            }

	            return $selectionCursor;
	        };

	        ['left', 'right', 'up', 'down']
	            .map(function (direction) { return this$1.keyboard.on(("shift+" + direction), function () { return this$1.selectArea(getNextSelectionCursor(direction)); }); });
	    }

	    bindCopyCellContents() {
	        var this$1 = this;

	        this.keyboard.on('ctrl+c', function () {
	            var noOfCellsCopied = this$1.copyCellContents(this$1.$focusedCell, this$1.$selectionCursor);
	            var message = noOfCellsCopied + " cell" + (noOfCellsCopied > 1 ? 's' : '') + " copied";
	            if (noOfCellsCopied) {
	                this$1.instance.showToastMessage(message, 2);
	            }
	        });

	        if (this.options.pasteFromClipboard) {
	            this.keyboard.on('ctrl+v', function (e) {
	                // hack
	                // https://stackoverflow.com/a/2177059/5353542
	                this$1.instance.pasteTarget.focus();

	                setTimeout(function () {
	                    var data = this$1.instance.pasteTarget.value;
	                    this$1.instance.pasteTarget.value = '';
	                    this$1.pasteContentInCell(data);
	                }, 10);

	                return false;
	            });
	        }
	    }

	    bindMouseEvents() {
	        var this$1 = this;

	        var mouseDown = null;

	        $.on(this.bodyScrollable, 'mousedown', '.dt-cell', function (e) {
	            mouseDown = true;
	            this$1.focusCell($(e.delegatedTarget));
	        });

	        $.on(this.bodyScrollable, 'mouseup', function () {
	            mouseDown = false;
	        });

	        var selectArea = function (e) {
	            if (!mouseDown) { return; }
	            this$1.selectArea($(e.delegatedTarget));
	        };

	        $.on(this.bodyScrollable, 'mousemove', '.dt-cell', throttle$1(selectArea, 50));
	    }

	    bindTreeEvents() {
	        var this$1 = this;

	        $.on(this.bodyScrollable, 'click', '.dt-tree-node__toggle', function (e, $toggle) {
	            var $cell = $.closest('.dt-cell', $toggle);
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;

	            if ($cell.classList.contains('dt-cell--tree-close')) {
	                this$1.rowmanager.openSingleNode(rowIndex);
	            } else {
	                this$1.rowmanager.closeSingleNode(rowIndex);
	            }
	        });
	    }

	    focusCell($cell, ref) {
	        if ( ref === void 0 ) ref = {};
	        var skipClearSelection = ref.skipClearSelection; if ( skipClearSelection === void 0 ) skipClearSelection = 0;

	        if (!$cell) { return; }

	        // don't focus if already editing cell
	        if ($cell === this.$editingCell) { return; }

	        var ref$1 = $.data($cell);
	        var colIndex = ref$1.colIndex;
	        var isHeader = ref$1.isHeader;
	        if (isHeader) {
	            return;
	        }

	        var column = this.columnmanager.getColumn(colIndex);
	        if (column.focusable === false) {
	            return;
	        }

	        this.scrollToCell($cell);

	        this.deactivateEditing();
	        if (!skipClearSelection) {
	            this.clearSelection();
	        }

	        if (this.$focusedCell) {
	            this.$focusedCell.classList.remove('dt-cell--focus');
	        }

	        this.$focusedCell = $cell;
	        $cell.classList.add('dt-cell--focus');

	        // so that keyboard nav works
	        $cell.focus();

	        this.highlightRowColumnHeader($cell);
	    }

	    unfocusCell($cell) {
	        if (!$cell) { return; }

	        // remove cell border
	        $cell.classList.remove('dt-cell--focus');
	        this.$focusedCell = null;

	        // reset header background
	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header.classList.remove('dt-cell--highlight'); });
	        }
	    }

	    highlightRowColumnHeader($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var srNoColIndex = this.datamanager.getColumnIndexById('_rowIndex');
	        var colHeaderSelector = ".dt-cell--header-" + colIndex;
	        var rowHeaderSelector = ".dt-cell--" + srNoColIndex + "-" + rowIndex;

	        if (this.lastHeaders) {
	            this.lastHeaders.forEach(function (header) { return header.classList.remove('dt-cell--highlight'); });
	        }

	        var colHeader = $(colHeaderSelector, this.wrapper);
	        var rowHeader = $(rowHeaderSelector, this.wrapper);

	        this.lastHeaders = [colHeader, rowHeader];
	        this.lastHeaders.forEach(function (header) { return header.classList.add('dt-cell--highlight'); });
	    }

	    selectAreaOnClusterChanged() {
	        if (!(this.$focusedCell && this.$selectionCursor)) { return; }
	        var ref = $.data(this.$selectionCursor);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell || $cell === this.$selectionCursor) { return; }

	        // selectArea needs $focusedCell
	        var fCell = $.data(this.$focusedCell);
	        this.$focusedCell = this.getCell$(fCell.colIndex, fCell.rowIndex);

	        this.selectArea($cell);
	    }

	    focusCellOnClusterChanged() {
	        if (!this.$focusedCell) { return; }

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;
	        var $cell = this.getCell$(colIndex, rowIndex);

	        if (!$cell) { return; }
	        // this function is called after selectAreaOnClusterChanged,
	        // focusCell calls clearSelection which resets the area selection
	        // so a flag to skip it
	        this.focusCell($cell, {
	            skipClearSelection: 1
	        });
	    }

	    selectArea($selectionCursor) {
	        if (!this.$focusedCell) { return; }

	        if (this._selectArea(this.$focusedCell, $selectionCursor)) {
	            // valid selection
	            this.$selectionCursor = $selectionCursor;
	        }
	    }

	    _selectArea($cell1, $cell2) {
	        var this$1 = this;

	        if ($cell1 === $cell2) { return false; }

	        var cells = this.getCellsInRange($cell1, $cell2);
	        if (!cells) { return false; }

	        this.clearSelection();
	        this._selectedCells = cells.map(function (index) {
	          var ref;

	          return (ref = this$1).getCell$.apply(ref, index);
	        });
	        requestAnimationFrame(function () {
	            this$1._selectedCells.map(function ($cell) { return $cell.classList.add('dt-cell--highlight'); });
	        });
	        return true;
	    }

	    getCellsInRange($cell1, $cell2) {
	        var assign, assign$1, assign$2;

	        var colIndex1, rowIndex1, colIndex2, rowIndex2;

	        if (typeof $cell1 === 'number') {
	            (assign = arguments, colIndex1 = assign[0], rowIndex1 = assign[1], colIndex2 = assign[2], rowIndex2 = assign[3]);
	        } else
	        if (typeof $cell1 === 'object') {
	            if (!($cell1 && $cell2)) {
	                return false;
	            }

	            var cell1 = $.data($cell1);
	            var cell2 = $.data($cell2);

	            colIndex1 = +cell1.colIndex;
	            rowIndex1 = +cell1.rowIndex;
	            colIndex2 = +cell2.colIndex;
	            rowIndex2 = +cell2.rowIndex;
	        }

	        if (rowIndex1 > rowIndex2) {
	            (assign$1 = [rowIndex2, rowIndex1], rowIndex1 = assign$1[0], rowIndex2 = assign$1[1]);
	        }

	        if (colIndex1 > colIndex2) {
	            (assign$2 = [colIndex2, colIndex1], colIndex1 = assign$2[0], colIndex2 = assign$2[1]);
	        }

	        if (this.isStandardCell(colIndex1) || this.isStandardCell(colIndex2)) {
	            return false;
	        }

	        var cells = [];
	        var colIndex = colIndex1;
	        var rowIndex = rowIndex1;
	        var rowIndices = [];

	        while (rowIndex <= rowIndex2) {
	            rowIndices.push(rowIndex);
	            rowIndex += 1;
	        }

	        rowIndices.map(function (rowIndex) {
	            while (colIndex <= colIndex2) {
	                cells.push([colIndex, rowIndex]);
	                colIndex++;
	            }
	            colIndex = colIndex1;
	        });

	        return cells;
	    }

	    clearSelection() {
	        (this._selectedCells || [])
	            .forEach(function ($cell) { return $cell.classList.remove('dt-cell--highlight'); });

	        this._selectedCells = [];
	        this.$selectionCursor = null;
	    }

	    getSelectionCursor() {
	        return this.$selectionCursor || this.$focusedCell;
	    }

	    activateEditing($cell) {
	        this.focusCell($cell);
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;

	        var col = this.columnmanager.getColumn(colIndex);
	        if (col && (col.editable === false || col.focusable === false)) {
	            return;
	        }

	        var cell = this.getCell(colIndex, rowIndex);
	        if (cell && cell.editable === false) {
	            return;
	        }

	        if (this.$editingCell) {
	            var ref$1 = $.data(this.$editingCell);
	            var _rowIndex = ref$1._rowIndex;
	            var _colIndex = ref$1._colIndex;

	            if (rowIndex === _rowIndex && colIndex === _colIndex) {
	                // editing the same cell
	                return;
	            }
	        }

	        this.$editingCell = $cell;
	        $cell.classList.add('dt-cell--editing');

	        var $editCell = $('.dt-cell__edit', $cell);
	        $editCell.innerHTML = '';

	        var editor = this.getEditor(colIndex, rowIndex, cell.content, $editCell);

	        if (editor) {
	            this.currentCellEditor = editor;
	            // initialize editing input with cell value
	            editor.initValue(cell.content, rowIndex, col);
	        }
	    }

	    deactivateEditing() {
	        // keep focus on the cell so that keyboard navigation works
	        if (this.$focusedCell) { this.$focusedCell.focus(); }

	        if (!this.$editingCell) { return; }
	        this.$editingCell.classList.remove('dt-cell--editing');
	        this.$editingCell = null;
	    }

	    getEditor(colIndex, rowIndex, value, parent) {
	        var column = this.datamanager.getColumn(colIndex);
	        var row = this.datamanager.getRow(rowIndex);
	        var data = this.datamanager.getData(rowIndex);
	        var editor = this.options.getEditor ?
	            this.options.getEditor(colIndex, rowIndex, value, parent, column, row, data) :
	            this.getDefaultEditor(parent);

	        if (editor === false) {
	            // explicitly returned false
	            return false;
	        }
	        if (editor === undefined) {
	            // didn't return editor, fallback to default
	            editor = this.getDefaultEditor(parent);
	        }

	        return editor;
	    }

	    getDefaultEditor(parent) {
	        var $input = $.create('input', {
	            class: 'dt-input',
	            type: 'text',
	            inside: parent
	        });

	        return {
	            initValue: function initValue(value) {
	                $input.focus();
	                $input.value = value;
	            },
	            getValue: function getValue() {
	                return $input.value;
	            },
	            setValue: function setValue(value) {
	                $input.value = value;
	            }
	        };
	    }

	    submitEditing() {
	        var this$1 = this;

	        if (!this.$editingCell) { return; }
	        var $cell = this.$editingCell;
	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        var colIndex = ref.colIndex;
	        var col = this.datamanager.getColumn(colIndex);

	        if ($cell) {
	            var editor = this.currentCellEditor;

	            if (editor) {
	                var valuePromise = editor.getValue();

	                // convert to stubbed Promise
	                if (!valuePromise.then) {
	                    valuePromise = Promise.resolve(valuePromise);
	                }

	                valuePromise.then(function (value) {
	                    var done = editor.setValue(value, rowIndex, col);
	                    var oldValue = this$1.getCell(colIndex, rowIndex).content;

	                    // update cell immediately
	                    this$1.updateCell(colIndex, rowIndex, value);
	                    $cell.focus();

	                    if (done && done.then) {
	                        // revert to oldValue if promise fails
	                        done.catch(function (e) {
	                            console.log(e);
	                            this$1.updateCell(colIndex, rowIndex, oldValue);
	                        });
	                    }
	                });
	            }
	        }

	        this.currentCellEditor = null;
	    }

	    copyCellContents($cell1, $cell2) {
	        var this$1 = this;

	        if (!$cell2 && $cell1) {
	            // copy only focusedCell
	            var ref = $.data($cell1);
	            var colIndex = ref.colIndex;
	            var rowIndex = ref.rowIndex;
	            var cell = this.getCell(colIndex, rowIndex);
	            copyTextToClipboard(cell.content);
	            return 1;
	        }
	        var cells = this.getCellsInRange($cell1, $cell2);

	        if (!cells) { return 0; }

	        var rows = cells
	            // get cell objects
	            .map(function (index) {
	              var ref;

	              return (ref = this$1).getCell.apply(ref, index);
	        })
	            // convert to array of rows
	            .reduce(function (acc, curr) {
	                var rowIndex = curr.rowIndex;

	                acc[rowIndex] = acc[rowIndex] || [];
	                acc[rowIndex].push(curr.content);

	                return acc;
	            }, []);

	        var values = rows
	            // join values by tab
	            .map(function (row) { return row.join('\t'); })
	            // join rows by newline
	            .join('\n');

	        copyTextToClipboard(values);

	        // return no of cells copied
	        return rows.reduce(function (total, row) { return total + row.length; }, 0);
	    }

	    pasteContentInCell(data) {
	        var this$1 = this;

	        if (!this.$focusedCell) { return; }

	        var matrix = data
	            .split('\n')
	            .map(function (row) { return row.split('\t'); })
	            .filter(function (row) { return row.length && row.every(function (it) { return it; }); });

	        var ref = $.data(this.$focusedCell);
	        var colIndex = ref.colIndex;
	        var rowIndex = ref.rowIndex;

	        var focusedCell = {
	            colIndex: +colIndex,
	            rowIndex: +rowIndex
	        };

	        matrix.forEach(function (row, i) {
	            var rowIndex = i + focusedCell.rowIndex;
	            row.forEach(function (cell, j) {
	                var colIndex = j + focusedCell.colIndex;
	                this$1.updateCell(colIndex, rowIndex, cell);
	            });
	        });
	    }

	    activateFilter(colIndex) {
	        this.columnmanager.toggleFilter();
	        this.columnmanager.focusFilter(colIndex);

	        if (!this.columnmanager.isFilterShown) {
	            // put focus back on cell
	            this.$focusedCell && this.$focusedCell.focus();
	        }
	    }

	    updateCell(colIndex, rowIndex, value) {
	        var cell = this.datamanager.updateCell(colIndex, rowIndex, {
	            content: value
	        });
	        this.refreshCell(cell);
	    }

	    refreshCell(cell) {
	        var $cell = $(this.selector(cell.colIndex, cell.rowIndex), this.bodyScrollable);
	        $cell.innerHTML = this.getCellContent(cell);
	    }

	    toggleTreeButton(rowIndex, flag) {
	        var colIndex = this.columnmanager.getFirstColumnIndex();
	        var $cell = this.getCell$(colIndex, rowIndex);
	        if ($cell) {
	            $cell.classList[flag ? 'remove' : 'add']('dt-cell--tree-close');
	        }
	    }

	    isStandardCell(colIndex) {
	        // Standard cells are in Sr. No and Checkbox column
	        return colIndex < this.columnmanager.getFirstColumnIndex();
	    }

	    getCell$(colIndex, rowIndex) {
	        return $(this.selector(colIndex, rowIndex), this.bodyScrollable);
	    }

	    getAboveCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $aboveRow = $cell.parentElement.previousElementSibling;
	        while ($aboveRow && $aboveRow.classList.contains('dt-row--hide')) {
	            $aboveRow = $aboveRow.previousElementSibling;
	        }

	        if (!$aboveRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $aboveRow);
	    }

	    getBelowCell$($cell) {
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;

	        var $belowRow = $cell.parentElement.nextElementSibling;
	        while ($belowRow && $belowRow.classList.contains('dt-row--hide')) {
	            $belowRow = $belowRow.nextElementSibling;
	        }

	        if (!$belowRow) { return $cell; }
	        return $((".dt-cell--col-" + colIndex), $belowRow);
	    }

	    getLeftCell$($cell) {
	        return $cell.previousElementSibling;
	    }

	    getRightCell$($cell) {
	        return $cell.nextElementSibling;
	    }

	    getLeftMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getFirstColumnIndex(), rowIndex);
	    }

	    getRightMostCell$(rowIndex) {
	        return this.getCell$(this.columnmanager.getLastColumnIndex(), rowIndex);
	    }

	    getTopMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getFirstRowIndex());
	    }

	    getBottomMostCell$(colIndex) {
	        return this.getCell$(colIndex, this.rowmanager.getLastRowIndex());
	    }

	    getCell(colIndex, rowIndex) {
	        return this.instance.datamanager.getCell(colIndex, rowIndex);
	    }

	    getRowHeight() {
	        return $.style($('.dt-row', this.bodyScrollable), 'height');
	    }

	    scrollToCell($cell) {
	        if ($.inViewport($cell, this.bodyScrollable)) { return false; }

	        var ref = $.data($cell);
	        var rowIndex = ref.rowIndex;
	        this.rowmanager.scrollToRow(rowIndex);
	        return false;
	    }

	    getRowCountPerPage() {
	        return Math.ceil(this.instance.getViewportHeight() / this.getRowHeight());
	    }

	    getCellHTML(cell) {
	        var rowIndex = cell.rowIndex;
	        var colIndex = cell.colIndex;
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var isTotalRow = cell.isTotalRow;
	        var dataAttr = makeDataAttributeString({
	            rowIndex: rowIndex,
	            colIndex: colIndex,
	            isHeader: isHeader,
	            isFilter: isFilter,
	            isTotalRow: isTotalRow
	        });

	        var row = this.datamanager.getRow(rowIndex);

	        var isBodyCell = !(isHeader || isFilter || isTotalRow);

	        var className = [
	            'dt-cell',
	            'dt-cell--col-' + colIndex,
	            isBodyCell ? ("dt-cell--" + colIndex + "-" + rowIndex) : '',
	            isBodyCell ? 'dt-cell--row-' + rowIndex : '',
	            isHeader ? 'dt-cell--header' : '',
	            isHeader ? ("dt-cell--header-" + colIndex) : '',
	            isFilter ? 'dt-cell--filter' : '',
	            isBodyCell && row.meta.isTreeNodeClose ? 'dt-cell--tree-close' : ''
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\" " + dataAttr + " tabindex=\"0\">\n                " + (this.getCellContent(cell)) + "\n            </div>\n        ");
	    }

	    getCellContent(cell) {
	        var isHeader = cell.isHeader;
	        var isFilter = cell.isFilter;
	        var colIndex = cell.colIndex;

	        var editable = !isHeader && cell.editable !== false;
	        var editCellHTML = editable ? this.getEditCellHTML(colIndex) : '';

	        var sortable = isHeader && cell.sortable !== false;
	        var sortIndicator = sortable ?
	            ("<span class=\"sort-indicator\">\n                " + (this.options.sortIndicator[cell.sortOrder]) + "\n            </span>") :
	            '';

	        var resizable = isHeader && cell.resizable !== false;
	        var resizeColumn = resizable ? '<span class="dt-cell__resize-handle"></span>' : '';

	        var hasDropdown = isHeader && cell.dropdown !== false;
	        var dropdown = hasDropdown ? this.columnmanager.getDropdownHTML() : '';

	        var customFormatter = cell.format || (cell.column && cell.column.format) || null;

	        var contentHTML;
	        if (isHeader || isFilter || !customFormatter) {
	            contentHTML = cell.content;
	        } else {
	            var row = this.datamanager.getRow(cell.rowIndex);
	            var data = this.datamanager.getData(cell.rowIndex);
	            contentHTML = customFormatter(cell.content, row, cell.column, data);
	        }

	        cell.html = contentHTML;

	        if (this.options.treeView && !(isHeader || isFilter) && cell.indent !== undefined) {
	            var nextRow = this.datamanager.getRow(cell.rowIndex + 1);
	            var addToggle = nextRow && nextRow.meta.indent > cell.indent;
	            var leftPadding = 20;
	            var unit = 'px';

	            // Add toggle and indent in the first column
	            var firstColumnIndex = this.datamanager.getColumnIndexById('_rowIndex') + 1;
	            if (firstColumnIndex === cell.colIndex) {
	                var padding = ((cell.indent || 0)) * leftPadding;
	                var toggleHTML = addToggle ?
	                    ("<span class=\"dt-tree-node__toggle\" style=\"left: " + (padding - leftPadding) + unit + "\">\n                        <span class=\"icon-open\">" + (icons.chevronDown) + "</span>\n                        <span class=\"icon-close\">" + (icons.chevronRight) + "</span>\n                    </span>") : '';
	                contentHTML = "<span class=\"dt-tree-node\" style=\"padding-left: " + padding + unit + "\">\n                    " + toggleHTML + "\n                    <span>" + contentHTML + "</span>\n                </span>";
	            }
	        }

	        var className = [
	            'dt-cell__content',
	            isHeader ? ("dt-cell__content--header-" + colIndex) : ("dt-cell__content--col-" + colIndex)
	        ].join(' ');

	        return ("\n            <div class=\"" + className + "\">\n                " + contentHTML + "\n                " + sortIndicator + "\n                " + resizeColumn + "\n                " + dropdown + "\n            </div>\n            " + editCellHTML + "\n        ");
	    }

	    getEditCellHTML(colIndex) {
	        return ("<div class=\"dt-cell__edit dt-cell__edit--col-" + colIndex + "\"></div>");
	    }

	    selector(colIndex, rowIndex) {
	        return (".dt-cell--" + colIndex + "-" + rowIndex);
	    }
	}

	class ColumnManager {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'header',
	            'datamanager',
	            'style',
	            'wrapper',
	            'rowmanager',
	            'bodyScrollable',
	            'bodyRenderer'
	        ]);

	        this.bindEvents();
	    }

	    renderHeader() {
	        this.header.innerHTML = '<div></div>';
	        this.refreshHeader();
	    }

	    refreshHeader() {
	        var columns = this.datamanager.getColumns();

	        // refresh html
	        $('div', this.header).innerHTML = this.getHeaderHTML(columns);

	        this.$filterRow = $('.dt-row-filter', this.header);
	        if (this.$filterRow) {
	            $.style(this.$filterRow, { display: 'none' });
	        }
	        // reset columnMap
	        this.$columnMap = [];
	        this.bindMoveColumn();
	    }

	    getHeaderHTML(columns) {
	        var html = this.rowmanager.getRowHTML(columns, {
	            isHeader: 1
	        });
	        if (this.options.inlineFilters) {
	            html += this.rowmanager.getRowHTML(columns, {
	                isFilter: 1
	            });
	        }
	        return html;
	    }

	    bindEvents() {
	        this.bindDropdown();
	        this.bindResizeColumn();
	        this.bindFilter();
	    }

	    bindDropdown() {
	        var this$1 = this;

	        var toggleClass = '.dt-dropdown__toggle';
	        var dropdownClass = '.dt-dropdown__list';

	        // attach the dropdown list to container
	        this.instance.dropdownContainer.innerHTML = this.getDropdownListHTML();
	        this.$dropdownList = this.instance.dropdownContainer.firstElementChild;

	        $.on(this.header, 'click', toggleClass, function (e) {
	            this$1.openDropdown(e);
	        });

	        var deactivateDropdownOnBodyClick = function (e) {
	            var selector = [
	                toggleClass, toggleClass + ' *',
	                dropdownClass, dropdownClass + ' *'
	            ].join(',');
	            if (e.target.matches(selector)) { return; }
	            deactivateDropdown();
	        };
	        $.on(document.body, 'click', deactivateDropdownOnBodyClick);
	        document.addEventListener('scroll', deactivateDropdown, true);

	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'click', deactivateDropdownOnBodyClick);
	            $.off(document, 'scroll', deactivateDropdown);
	        });

	        $.on(this.$dropdownList, 'click', '.dt-dropdown__list-item', function (e, $item) {
	            if (!this$1._dropdownActiveColIndex) { return; }
	            var dropdownItems = this$1.options.headerDropdown;
	            var ref = $.data($item);
	            var index = ref.index;
	            var colIndex = this$1._dropdownActiveColIndex;
	            var callback = dropdownItems[index].action;

	            callback && callback.call(this$1.instance, this$1.getColumn(colIndex));
	            this$1.hideDropdown();
	        });

	        var _this = this;
	        function deactivateDropdown(e) {
	            _this.hideDropdown();
	        }

	        this.hideDropdown();
	    }

	    openDropdown(e) {
	        if (!this._dropdownWidth) {
	            $.style(this.$dropdownList, { display: '' });
	            this._dropdownWidth = $.style(this.$dropdownList, 'width');
	        }
	        $.style(this.$dropdownList, {
	            display: '',
	            left: (e.clientX - this._dropdownWidth + 4) + 'px',
	            top: (e.clientY + 4) + 'px'
	        });
	        var $cell = $.closest('.dt-cell', e.target);
	        var ref = $.data($cell);
	        var colIndex = ref.colIndex;
	        this._dropdownActiveColIndex = colIndex;
	    }

	    hideDropdown() {
	        $.style(this.$dropdownList, {
	            display: 'none'
	        });
	        this._dropdownActiveColIndex = null;
	    }

	    bindResizeColumn() {
	        var this$1 = this;

	        var isDragging = false;
	        var $resizingCell, startWidth, startX;

	        $.on(this.header, 'mousedown', '.dt-cell .dt-cell__resize-handle', function (e, $handle) {
	            document.body.classList.add('dt-resize');
	            var $cell = $handle.parentNode.parentNode;
	            $resizingCell = $cell;
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            var col = this$1.getColumn(colIndex);

	            if (col && col.resizable === false) {
	                return;
	            }

	            isDragging = true;
	            startWidth = $.style($('.dt-cell__content', $resizingCell), 'width');
	            startX = e.pageX;
	        });

	        var onMouseup = function (e) {
	            document.body.classList.remove('dt-resize');
	            if (!$resizingCell) { return; }
	            isDragging = false;

	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;
	            this$1.setColumnWidth(colIndex);
	            this$1.style.setBodyStyle();
	            $resizingCell = null;
	        };
	        $.on(document.body, 'mouseup', onMouseup);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mouseup', onMouseup);
	        });

	        var onMouseMove = function (e) {
	            if (!isDragging) { return; }
	            var finalWidth = startWidth + (e.pageX - startX);
	            var ref = $.data($resizingCell);
	            var colIndex = ref.colIndex;

	            if (this$1.getColumnMinWidth(colIndex) > finalWidth) {
	                // don't resize past minWidth
	                return;
	            }
	            this$1.datamanager.updateColumn(colIndex, {
	                width: finalWidth
	            });
	            this$1.setColumnHeaderWidth(colIndex);
	        };
	        $.on(document.body, 'mousemove', onMouseMove);
	        this.instance.on('onDestroy', function () {
	            $.off(document.body, 'mousemove', onMouseMove);
	        });
	    }

	    bindMoveColumn() {
	        var this$1 = this;

	        var $parent = $('.dt-row', this.header);

	        this.sortable = Sortable$$1.create($parent, {
	            onEnd: function (e) {
	                var oldIndex = e.oldIndex;
	                var newIndex = e.newIndex;
	                var $draggedCell = e.item;
	                var ref = $.data($draggedCell);
	                var colIndex = ref.colIndex;
	                if (+colIndex === newIndex) { return; }

	                this$1.switchColumn(oldIndex, newIndex);
	            },
	            preventOnFilter: false,
	            filter: '.dt-cell__resize-handle, .dt-dropdown',
	            chosenClass: 'dt-cell--dragging',
	            animation: 150
	        });
	    }

	    sortColumn(colIndex, nextSortOrder) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.sortRows(colIndex, nextSortOrder)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onSortColumn', this$1.getColumn(colIndex));
	            });
	    }

	    removeColumn(colIndex) {
	        var this$1 = this;

	        var removedCol = this.getColumn(colIndex);
	        this.instance.freeze();
	        this.datamanager.removeColumn(colIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () { return this$1.instance.unfreeze(); })
	            .then(function () {
	                this$1.fireEvent('onRemoveColumn', removedCol);
	            });
	    }

	    switchColumn(oldIndex, newIndex) {
	        var this$1 = this;

	        this.instance.freeze();
	        this.datamanager.switchColumn(oldIndex, newIndex)
	            .then(function () {
	                this$1.refreshHeader();
	                return this$1.rowmanager.refreshRows();
	            })
	            .then(function () {
	                this$1.setColumnWidth(oldIndex);
	                this$1.setColumnWidth(newIndex);
	                this$1.instance.unfreeze();
	            })
	            .then(function () {
	                this$1.fireEvent('onSwitchColumn',
	                    this$1.getColumn(oldIndex), this$1.getColumn(newIndex)
	                );
	            });
	    }

	    toggleFilter(flag) {
	        if (!this.options.inlineFilters) { return; }

	        var showFilter;
	        if (flag === undefined) {
	            showFilter = !this.isFilterShown;
	        } else {
	            showFilter = flag;
	        }

	        if (showFilter) {
	            $.style(this.$filterRow, { display: '' });
	        } else {
	            $.style(this.$filterRow, { display: 'none' });
	        }

	        this.isFilterShown = showFilter;
	        this.style.setBodyStyle();
	    }

	    focusFilter(colIndex) {
	        if (!this.isFilterShown) { return; }

	        var $filterInput = $((".dt-cell--col-" + colIndex + " .dt-filter"), this.$filterRow);
	        $filterInput.focus();
	    }

	    bindFilter() {
	        var this$1 = this;

	        if (!this.options.inlineFilters) { return; }
	        var handler = function (e) {
	            this$1.applyFilter(this$1.getAppliedFilters());
	        };
	        $.on(this.header, 'keydown', '.dt-filter', debounce$1(handler, 300));
	    }

	    applyFilter(filters) {
	        var this$1 = this;

	        this.datamanager.filterRows(filters)
	            .then(function (ref) {
	                var rowsToShow = ref.rowsToShow;

	                this$1.rowmanager.showRows(rowsToShow);
	            });
	    }

	    getAppliedFilters() {
	        var filters = {};
	        $.each('.dt-filter', this.header).map(function (input) {
	            var value = input.value;
	            if (value) {
	                filters[input.dataset.colIndex] = value;
	            }
	        });
	        return filters;
	    }

	    applyDefaultSortOrder() {
	        // sort rows if any 1 column has a default sortOrder set
	        var columnsToSort = this.getColumns().filter(function (col) { return col.sortOrder !== 'none'; });

	        if (columnsToSort.length === 1) {
	            var column = columnsToSort[0];
	            this.sortColumn(column.colIndex, column.sortOrder);
	        }
	    }

	    sortRows(colIndex, sortOrder) {
	        return this.datamanager.sortRows(colIndex, sortOrder);
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    setColumnWidth(colIndex, width) {
	        colIndex = +colIndex;

	        var columnWidth = width || this.getColumn(colIndex).width;

	        var selector = [
	            (".dt-cell__content--col-" + colIndex),
	            (".dt-cell__edit--col-" + colIndex)
	        ].join(', ');

	        var styles = {
	            width: columnWidth + 'px'
	        };

	        this.style.setStyle(selector, styles);
	    }

	    setColumnHeaderWidth(colIndex) {
	        colIndex = +colIndex;
	        this.$columnMap = this.$columnMap || [];
	        var selector = ".dt-cell__content--header-" + colIndex;
	        var ref = this.getColumn(colIndex);
	        var width = ref.width;

	        var $column = this.$columnMap[colIndex];
	        if (!$column) {
	            $column = this.header.querySelector(selector);
	            this.$columnMap[colIndex] = $column;
	        }

	        $column.style.width = width + 'px';
	    }

	    getColumnMinWidth(colIndex) {
	        colIndex = +colIndex;
	        return this.getColumn(colIndex).minWidth || 24;
	    }

	    getFirstColumnIndex() {
	        return this.datamanager.getColumnIndexById('_rowIndex') + 1;
	    }

	    getHeaderCell$(colIndex) {
	        return $((".dt-cell--header-" + colIndex), this.header);
	    }

	    getLastColumnIndex() {
	        return this.datamanager.getColumnCount() - 1;
	    }

	    getDropdownHTML() {
	        var ref = this.options;
	        var dropdownButton = ref.dropdownButton;

	        return ("\n            <div class=\"dt-dropdown\">\n                <div class=\"dt-dropdown__toggle\">" + dropdownButton + "</div>\n            </div>\n      ");
	    }

	    getDropdownListHTML() {
	        var ref = this.options;
	        var dropdownItems = ref.headerDropdown;

	        return ("\n            <div class=\"dt-dropdown__list\">\n            " + (dropdownItems.map(function (d, i) { return ("\n                <div class=\"dt-dropdown__list-item\" data-index=\"" + i + "\">" + (d.label) + "</div>\n            "); }).join('')) + "\n            </div>\n        ");
	    }
	}

	class RowManager {
	    constructor(instance) {
	        this.instance = instance;
	        linkProperties(this, this.instance, [
	            'options',
	            'fireEvent',
	            'wrapper',
	            'bodyScrollable',
	            'bodyRenderer',
	            'style'
	        ]);

	        this.bindEvents();
	        this.refreshRows = nextTick(this.refreshRows, this);
	    }

	    get datamanager() {
	        return this.instance.datamanager;
	    }

	    get cellmanager() {
	        return this.instance.cellmanager;
	    }

	    bindEvents() {
	        this.bindCheckbox();
	    }

	    bindCheckbox() {
	        var this$1 = this;

	        if (!this.options.checkboxColumn) { return; }

	        // map of checked rows
	        this.checkMap = [];

	        $.on(this.wrapper, 'click', '.dt-cell--col-0 [type="checkbox"]', function (e, $checkbox) {
	            var $cell = $checkbox.closest('.dt-cell');
	            var ref = $.data($cell);
	            var rowIndex = ref.rowIndex;
	            var isHeader = ref.isHeader;
	            var checked = $checkbox.checked;

	            if (isHeader) {
	                this$1.checkAll(checked);
	            } else {
	                this$1.checkRow(rowIndex, checked);
	            }
	        });
	    }

	    refreshRows() {
	        this.instance.renderBody();
	        this.instance.setDimensions();
	    }

	    refreshRow(row, rowIndex) {
	        var this$1 = this;

	        var _row = this.datamanager.updateRow(row, rowIndex);

	        _row.forEach(function (cell) {
	            this$1.cellmanager.refreshCell(cell);
	        });
	    }

	    getCheckedRows() {
	        var this$1 = this;

	        if (!this.checkMap) {
	            return [];
	        }

	        var out = [];
	        for (var rowIndex in this$1.checkMap) {
	            var checked = this$1.checkMap[rowIndex];
	            if (checked === 1) {
	                out.push(rowIndex);
	            }
	        }

	        return out;
	    }

	    highlightCheckedRows() {
	        var this$1 = this;

	        this.getCheckedRows()
	            .map(function (rowIndex) { return this$1.checkRow(rowIndex, true); });
	    }

	    checkRow(rowIndex, toggle) {
	        var value = toggle ? 1 : 0;
	        var selector = function (rowIndex) { return (".dt-cell--0-" + rowIndex + " [type=\"checkbox\"]"); };
	        // update internal map
	        this.checkMap[rowIndex] = value;
	        // set checkbox value explicitly
	        $.each(selector(rowIndex), this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight row
	        this.highlightRow(rowIndex, toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow', this.datamanager.getRow(rowIndex));
	    }

	    checkAll(toggle) {
	        var value = toggle ? 1 : 0;

	        // update internal map
	        if (toggle) {
	            this.checkMap = Array.from(Array(this.getTotalRows())).map(function (c) { return value; });
	        } else {
	            this.checkMap = [];
	        }
	        // set checkbox value
	        $.each('.dt-cell--col-0 [type="checkbox"]', this.bodyScrollable)
	            .map(function (input) {
	                input.checked = toggle;
	            });
	        // highlight all
	        this.highlightAll(toggle);
	        this.showCheckStatus();
	        this.fireEvent('onCheckRow');
	    }

	    showCheckStatus() {
	        if (!this.options.checkedRowStatus) { return; }
	        var checkedRows = this.getCheckedRows();
	        var count = checkedRows.length;
	        if (count > 0) {
	            this.bodyRenderer.showToastMessage((count + " row" + (count > 1 ? 's' : '') + " selected"));
	        } else {
	            this.bodyRenderer.clearToastMessage();
	        }
	    }

	    highlightRow(rowIndex, toggle) {
	        if ( toggle === void 0 ) toggle = true;

	        var $row = this.getRow$(rowIndex);
	        if (!$row) { return; }

	        if (!toggle && this.bodyScrollable.classList.contains('dt-scrollable--highlight-all')) {
	            $row.classList.add('dt-row--unhighlight');
	            return;
	        }

	        if (toggle && $row.classList.contains('dt-row--unhighlight')) {
	            $row.classList.remove('dt-row--unhighlight');
	        }

	        this._highlightedRows = this._highlightedRows || {};

	        if (toggle) {
	            $row.classList.add('dt-row--highlight');
	            this._highlightedRows[rowIndex] = $row;
	        } else {
	            $row.classList.remove('dt-row--highlight');
	            delete this._highlightedRows[rowIndex];
	        }
	    }

	    highlightAll(toggle) {
	        var this$1 = this;
	        if ( toggle === void 0 ) toggle = true;

	        if (toggle) {
	            this.bodyScrollable.classList.add('dt-scrollable--highlight-all');
	        } else {
	            this.bodyScrollable.classList.remove('dt-scrollable--highlight-all');
	            for (var rowIndex in this$1._highlightedRows) {
	                var $row = this$1._highlightedRows[rowIndex];
	                $row.classList.remove('dt-row--highlight');
	            }
	            this._highlightedRows = {};
	        }
	    }

	    showRows(rowIndices) {
	        var this$1 = this;

	        rowIndices = ensureArray(rowIndices);
	        var rows = rowIndices.map(function (rowIndex) { return this$1.datamanager.getRow(rowIndex); });
	        this.bodyRenderer.renderRows(rows);
	    }

	    showAllRows() {
	        var rowIndices = this.datamanager.getAllRowIndices();
	        this.showRows(rowIndices);
	    }

	    openSingleNode(rowIndex) {
	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = false;

	        var childrenToShow = this.datamanager.getImmediateChildren(rowIndex);
	        var visibleRowIndices = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = uniq$1(childrenToShow.concat( visibleRowIndices)).sort(numberSortAsc);

	        this.showRows(rowsToShow);
	    }

	    closeSingleNode(rowIndex) {
	        var this$1 = this;

	        var row = this.datamanager.getRow(rowIndex);
	        row.meta.isTreeNodeClose = true;

	        var rowsToHide = this.datamanager.getChildren(rowIndex);
	        var visibleRows = this.bodyRenderer.visibleRowIndices;
	        var rowsToShow = visibleRows
	            .filter(function (rowIndex) { return !rowsToHide.includes(rowIndex); })
	            .sort(numberSortAsc);

	        rowsToHide.forEach(function (rowIndex) {
	            var row = this$1.datamanager.getRow(rowIndex);
	            if (!row.meta.isLeaf) {
	                row.meta.isTreeNodeClose = true;
	            }
	        });

	        this.showRows(rowsToShow);
	    }

	    getRow$(rowIndex) {
	        return $(this.selector(rowIndex), this.bodyScrollable);
	    }

	    getTotalRows() {
	        return this.datamanager.getRowCount();
	    }

	    getFirstRowIndex() {
	        return 0;
	    }

	    getLastRowIndex() {
	        return this.datamanager.getRowCount() - 1;
	    }

	    scrollToRow(rowIndex) {
	        rowIndex = +rowIndex;
	        this._lastScrollTo = this._lastScrollTo || 0;
	        var $row = this.getRow$(rowIndex);
	        if ($.inViewport($row, this.bodyScrollable)) { return; }

	        var ref = $row.getBoundingClientRect();
	        var height = ref.height;
	        var ref$1 = this.bodyScrollable.getBoundingClientRect();
	        var top = ref$1.top;
	        var bottom = ref$1.bottom;
	        var rowsInView = Math.floor((bottom - top) / height);

	        var offset = 0;
	        if (rowIndex > this._lastScrollTo) {
	            offset = height * ((rowIndex + 1) - rowsInView);
	        } else {
	            offset = height * ((rowIndex + 1) - 1);
	        }

	        this._lastScrollTo = rowIndex;
	        $.scrollTop(this.bodyScrollable, offset);
	    }

	    getRowHTML(row, props) {
	        var this$1 = this;

	        var dataAttr = makeDataAttributeString(props);
	        var rowIdentifier = props.rowIndex;

	        if (props.isFilter) {
	            row = row.map(function (cell) { return (Object.assign({}, cell, {
	                content: this$1.getFilterInput({
	                    colIndex: cell.colIndex
	                }),
	                isFilter: 1,
	                isHeader: undefined,
	                editable: false
	            })); });

	            rowIdentifier = 'filter';
	        }

	        if (props.isHeader) {
	            rowIdentifier = 'header';
	        }

	        return ("\n            <div class=\"dt-row dt-row-" + rowIdentifier + "\" " + dataAttr + ">\n                " + (row.map(function (cell) { return this$1.cellmanager.getCellHTML(cell); }).join('')) + "\n            </div>\n        ");
	    }

	    getFilterInput(props) {
	        var dataAttr = makeDataAttributeString(props);
	        return ("<input class=\"dt-filter dt-input\" type=\"text\" " + dataAttr + " tabindex=\"1\" />");
	    }

	    selector(rowIndex) {
	        return (".dt-row-" + rowIndex);
	    }
	}

	var hyperlist = createCommonjsModule$$1(function (module, exports) {
	(function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire$$1=="function"&&commonjsRequire$$1;if(!u&&a){ return a(o,!0); }if(i){ return i(o,!0); }var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire$$1=="function"&&commonjsRequire$$1;for(var o=0;o<r.length;o++){ s(r[o]); }return s})({1:[function(_dereq_,module,exports){

	// Default configuration.

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultConfig = {
	  width: '100%',
	  height: '100%'
	};

	// Check for valid number.
	var isNumber = function isNumber(input) {
	  return Number(input) === Number(input);
	};

	/**
	 * Creates a HyperList instance that virtually scrolls very large amounts of
	 * data effortlessly.
	 */

	var HyperList = function () {
	  _createClass(HyperList, null, [{
	    key: 'create',
	    value: function create(element, userProvidedConfig) {
	      return new HyperList(element, userProvidedConfig);
	    }

	    /**
	     * Merge given css style on an element
	     * @param {DOMElement} element
	     * @param {Object} style
	     */

	  }, {
	    key: 'mergeStyle',
	    value: function mergeStyle(element, style) {
	      for (var i in style) {
	        if (element.style[i] !== style[i]) {
	          element.style[i] = style[i];
	        }
	      }
	    }
	  }, {
	    key: 'getMaxBrowserHeight',
	    value: function getMaxBrowserHeight() {
	      // Create two elements, the wrapper is `1px` tall and is transparent and
	      // positioned at the top of the page. Inside that is an element that gets
	      // set to 1 billion pixels. Then reads the max height the browser can
	      // calculate.
	      var wrapper = document.createElement('div');
	      var fixture = document.createElement('div');

	      // As said above, these values get set to put the fixture elements into the
	      // right visual state.
	      HyperList.mergeStyle(wrapper, { position: 'absolute', height: '1px', opacity: 0 });
	      HyperList.mergeStyle(fixture, { height: '1e7px' });

	      // Add the fixture into the wrapper element.
	      wrapper.appendChild(fixture);

	      // Apply to the page, the values won't kick in unless this is attached.
	      document.body.appendChild(wrapper);

	      // Get the maximum element height in pixels.
	      var maxElementHeight = fixture.offsetHeight;

	      // Remove the element immediately after reading the value.
	      document.body.removeChild(wrapper);

	      return maxElementHeight;
	    }
	  }]);

	  function HyperList(element, userProvidedConfig) {
	    var _this = this;

	    _classCallCheck(this, HyperList);

	    this._config = {};
	    this._lastRepaint = null;
	    this._maxElementHeight = HyperList.getMaxBrowserHeight();

	    this.refresh(element, userProvidedConfig);

	    var config = this._config;

	    // Create internal render loop.
	    var render = function render() {
	      var scrollTop = _this._getScrollPosition();
	      var lastRepaint = _this._lastRepaint;

	      _this._renderAnimationFrame = window.requestAnimationFrame(render);

	      if (scrollTop === lastRepaint) {
	        return;
	      }

	      if (!lastRepaint || Math.abs(scrollTop - lastRepaint) > _this._averageHeight) {
	        var rendered = _this._renderChunk();

	        _this._lastRepaint = scrollTop;

	        if (rendered !== false && typeof config.afterRender === 'function') {
	          config.afterRender();
	        }
	      }
	    };

	    render();
	  }

	  _createClass(HyperList, [{
	    key: 'destroy',
	    value: function destroy() {
	      window.cancelAnimationFrame(this._renderAnimationFrame);
	    }
	  }, {
	    key: 'refresh',
	    value: function refresh(element, userProvidedConfig) {
	      var _this2 = this;

	      Object.assign(this._config, defaultConfig, userProvidedConfig);

	      if (!element || element.nodeType !== 1) {
	        throw new Error('HyperList requires a valid DOM Node container');
	      }

	      this._element = element;

	      var config = this._config;

	      var scroller = this._scroller || config.scroller || document.createElement(config.scrollerTagName || 'tr');

	      // Default configuration option `useFragment` to `true`.
	      if (typeof config.useFragment !== 'boolean') {
	        this._config.useFragment = true;
	      }

	      if (!config.generate) {
	        throw new Error('Missing required `generate` function');
	      }

	      if (!isNumber(config.total)) {
	        throw new Error('Invalid required `total` value, expected number');
	      }

	      if (!Array.isArray(config.itemHeight) && !isNumber(config.itemHeight)) {
	        throw new Error('\n        Invalid required `itemHeight` value, expected number or array\n      '.trim());
	      } else if (isNumber(config.itemHeight)) {
	        this._itemHeights = Array(config.total).fill(config.itemHeight);
	      } else {
	        this._itemHeights = config.itemHeight;
	      }

	      // Width and height should be coerced to string representations. Either in
	      // `%` or `px`.
	      Object.keys(defaultConfig).filter(function (prop) {
	        return prop in config;
	      }).forEach(function (prop) {
	        var value = config[prop];
	        var isValueNumber = isNumber(value);
	        var isValuePercent = isValueNumber ? false : value.slice(-1) === '%';

	        if (value && typeof value !== 'string' && typeof value !== 'number') {
	          var msg = 'Invalid optional `' + prop + '`, expected string or number';
	          throw new Error(msg);
	        } else if (isValueNumber) {
	          config[prop] = value + 'px';
	        }

	        if (prop !== 'height') {
	          return;
	        }

	        // Compute the containerHeight as number
	        var numberValue = isValueNumber ? value : parseInt(value.replace(/px|%/, ''), 10);

	        if (isValuePercent) {
	          _this2._containerHeight = window.innerHeight * numberValue / 100;
	        } else {
	          _this2._containerHeight = isNumber(value) ? value : numberValue;
	        }
	      });

	      // Decorate the container element with styles that will match
	      // the user supplied configuration.
	      var elementStyle = {
	        width: '' + config.width,
	        height: '' + config.height,
	        overflow: 'auto',
	        position: 'relative'
	      };

	      HyperList.mergeStyle(element, elementStyle);

	      var scrollerHeight = config.itemHeight * config.total;
	      var maxElementHeight = this._maxElementHeight;

	      if (scrollerHeight > maxElementHeight) {
	        console.warn(['HyperList: The maximum element height', maxElementHeight + 'px has', 'been exceeded; please reduce your item height.'].join(' '));
	      }

	      var scrollerStyle = {
	        opacity: '0',
	        position: 'absolute',
	        width: '1px',
	        height: scrollerHeight + 'px'
	      };

	      HyperList.mergeStyle(scroller, scrollerStyle);

	      // Only append the scroller element once.
	      if (!this._scroller) {
	        element.appendChild(scroller);
	      }

	      // Set the scroller instance.
	      this._scroller = scroller;
	      this._scrollHeight = this._computeScrollHeight();

	      // Reuse the item positions if refreshed, otherwise set to empty array.
	      this._itemPositions = this._itemPositions || Array(config.total).fill(0);

	      // Each index in the array should represent the position in the DOM.
	      this._computePositions(0);

	      // Render after refreshing. Force render if we're calling refresh manually.
	      this._renderChunk(this._lastRepaint !== null);

	      if (typeof config.afterRender === 'function') {
	        config.afterRender();
	      }
	    }
	  }, {
	    key: '_getRow',
	    value: function _getRow(i) {
	      var config = this._config;
	      var item = config.generate(i);
	      var height = item.height;

	      if (height !== undefined && isNumber(height)) {
	        item = item.element;

	        // The height isn't the same as predicted, compute positions again
	        if (height !== this._itemHeights) {
	          this._itemHeights[i] = height;
	          this._computePositions(i);
	          this._scrollHeight = this._computeScrollHeight(i);
	        }
	      } else {
	        height = this._itemHeights[i];
	      }

	      if (!item || item.nodeType !== 1) {
	        throw new Error('Generator did not return a DOM Node for index: ' + i);
	      }

	      var oldClass = item.getAttribute('class') || '';
	      item.setAttribute('class', oldClass + ' ' + (config.rowClassName || 'vrow'));

	      var top = this._itemPositions[i];

	      HyperList.mergeStyle(item, {
	        position: 'absolute',
	        top: top + 'px'
	      });

	      return item;
	    }
	  }, {
	    key: '_getScrollPosition',
	    value: function _getScrollPosition() {
	      var config = this._config;

	      if (typeof config.overrideScrollPosition === 'function') {
	        return config.overrideScrollPosition();
	      }

	      return this._element.scrollTop;
	    }
	  }, {
	    key: '_renderChunk',
	    value: function _renderChunk(force) {
	      var this$1 = this;

	      var config = this._config;
	      var element = this._element;
	      var scrollTop = this._getScrollPosition();
	      var total = config.total;

	      var from = config.reverse ? this._getReverseFrom(scrollTop) : this._getFrom(scrollTop) - 1;

	      if (from < 0 || from - this._screenItemsLen < 0) {
	        from = 0;
	      }

	      if (!force && this._lastFrom === from) {
	        return false;
	      }

	      this._lastFrom = from;

	      var to = from + this._cachedItemsLen;

	      if (to > total || to + this._cachedItemsLen > total) {
	        to = total;
	      }

	      // Append all the new rows in a document fragment that we will later append
	      // to the parent node
	      var fragment = config.useFragment ? document.createDocumentFragment() : []
	      // Sometimes you'll pass fake elements to this tool and Fragments require
	      // real elements.


	      // The element that forces the container to scroll.
	      ;var scroller = this._scroller;

	      // Keep the scroller in the list of children.
	      fragment[config.useFragment ? 'appendChild' : 'push'](scroller);

	      for (var i = from; i < to; i++) {
	        var row = this$1._getRow(i);

	        fragment[config.useFragment ? 'appendChild' : 'push'](row);
	      }

	      if (config.applyPatch) {
	        return config.applyPatch(element, fragment);
	      }

	      element.innerHTML = '';
	      element.appendChild(fragment);
	    }
	  }, {
	    key: '_computePositions',
	    value: function _computePositions() {
	      var this$1 = this;

	      var from = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

	      var config = this._config;
	      var total = config.total;
	      var reverse = config.reverse;

	      if (from < 1 && !reverse) {
	        from = 1;
	      }

	      for (var i = from; i < total; i++) {
	        if (reverse) {
	          if (i === 0) {
	            this$1._itemPositions[0] = this$1._scrollHeight - this$1._itemHeights[0];
	          } else {
	            this$1._itemPositions[i] = this$1._itemPositions[i - 1] - this$1._itemHeights[i];
	          }
	        } else {
	          this$1._itemPositions[i] = this$1._itemHeights[i - 1] + this$1._itemPositions[i - 1];
	        }
	      }
	    }
	  }, {
	    key: '_computeScrollHeight',
	    value: function _computeScrollHeight() {
	      var _this3 = this;

	      var config = this._config;
	      var total = config.total;
	      var scrollHeight = this._itemHeights.reduce(function (a, b) {
	        return a + b;
	      }, 0);

	      HyperList.mergeStyle(this._scroller, {
	        opacity: 0,
	        position: 'absolute',
	        width: '1px',
	        height: scrollHeight + 'px'
	      });

	      // Calculate the height median
	      var sortedItemHeights = this._itemHeights.slice(0).sort(function (a, b) {
	        return a - b;
	      });
	      var middle = Math.floor(total / 2);
	      var averageHeight = total % 2 === 0 ? (sortedItemHeights[middle] + sortedItemHeights[middle - 1]) / 2 : sortedItemHeights[middle];

	      var containerHeight = this._element.clientHeight ? this._element.clientHeight : this._containerHeight;
	      this._screenItemsLen = Math.ceil(containerHeight / averageHeight);
	      this._containerHeight = containerHeight;

	      // Cache 3 times the number of items that fit in the container viewport.
	      this._cachedItemsLen = Math.max(this._cachedItemsLen || 0, this._screenItemsLen * 3);
	      this._averageHeight = averageHeight;

	      if (config.reverse) {
	        window.requestAnimationFrame(function () {
	          _this3._element.scrollTop = scrollHeight;
	        });
	      }

	      return scrollHeight;
	    }
	  }, {
	    key: '_getFrom',
	    value: function _getFrom(scrollTop) {
	      var i = 0;

	      while (this._itemPositions[i] < scrollTop) {
	        i++;
	      }

	      return i;
	    }
	  }, {
	    key: '_getReverseFrom',
	    value: function _getReverseFrom(scrollTop) {
	      var i = this._config.total - 1;

	      while (i > 0 && this._itemPositions[i] < scrollTop + this._containerHeight) {
	        i--;
	      }

	      return i;
	    }
	  }]);

	  return HyperList;
	}();

	exports.default = HyperList;
	module.exports = exports['default'];

	},{}]},{},[1])(1)
	});
	});

	var HyperList = unwrapExports$$1(hyperlist);

	class BodyRenderer {
	    constructor(instance) {
	        this.instance = instance;
	        this.options = instance.options;
	        this.datamanager = instance.datamanager;
	        this.rowmanager = instance.rowmanager;
	        this.cellmanager = instance.cellmanager;
	        this.bodyScrollable = instance.bodyScrollable;
	        this.footer = this.instance.footer;
	        this.log = instance.log;
	    }

	    renderRows(rows) {
	        var this$1 = this;

	        this.visibleRows = rows;
	        this.visibleRowIndices = rows.map(function (row) { return row.meta.rowIndex; });

	        var rowViewOrder = this.datamanager.rowViewOrder.map(function (index) {
	            if (this$1.visibleRowIndices.includes(index)) {
	                return index;
	            }
	            return null;
	        }).filter(function (index) { return index !== null; });

	        var computedStyle = getComputedStyle(this.bodyScrollable);

	        var config = {
	            width: computedStyle.width,
	            height: computedStyle.height,
	            itemHeight: this.options.cellHeight,
	            total: rows.length,
	            generate: function (index) {
	                var el = document.createElement('div');
	                var rowIndex = rowViewOrder[index];
	                var row = this$1.datamanager.getRow(rowIndex);
	                var rowHTML = this$1.rowmanager.getRowHTML(row, row.meta);
	                el.innerHTML = rowHTML;
	                return el.children[0];
	            },
	            afterRender: function () {
	                this$1.restoreState();
	            }
	        };

	        if (!this.hyperlist) {
	            this.hyperlist = new HyperList(this.bodyScrollable, config);
	        } else {
	            this.hyperlist.refresh(this.bodyScrollable, config);
	        }

	        this.renderFooter();
	    }

	    render() {
	        var rows = this.datamanager.getRowsForView();
	        this.renderRows(rows);
	        // setDimensions requires atleast 1 row to exist in dom
	        this.instance.setDimensions();
	    }

	    renderFooter() {
	        if (!this.options.showTotalRow) { return; }

	        var totalRow = this.getTotalRow();
	        var html = this.rowmanager.getRowHTML(totalRow, { isTotalRow: 1, rowIndex: 'totalRow' });

	        this.footer.innerHTML = html;
	    }

	    getTotalRow() {
	        var columns = this.datamanager.getColumns();
	        var totalRowTemplate = columns.map(function (col) {
	            var content = 0;
	            if (['_rowIndex', '_checkbox'].includes(col.id)) {
	                content = '';
	            }
	            return {
	                content: content,
	                isTotalRow: 1,
	                colIndex: col.colIndex,
	                column: col
	            };
	        });
	        var totalRow = this.visibleRows.reduce(function (acc, prevRow) {
	            return acc.map(function (cell, i) {
	                var prevCell = prevRow[i];
	                if (typeof prevCell.content === 'number') {
	                    cell.content += prevRow[i].content;
	                }
	                if (!cell.format && prevCell.format) {
	                    cell.format = prevCell.format;
	                }
	                return Object.assign({}, cell);
	            });
	        }, totalRowTemplate);
	        return totalRow;
	    }

	    restoreState() {
	        this.rowmanager.highlightCheckedRows();
	        this.cellmanager.selectAreaOnClusterChanged();
	        this.cellmanager.focusCellOnClusterChanged();
	    }

	    showToastMessage(message, hideAfter) {
	        var this$1 = this;

	        this.instance.toastMessage.innerHTML = this.getToastMessageHTML(message);

	        if (hideAfter) {
	            setTimeout(function () {
	                this$1.clearToastMessage();
	            }, hideAfter * 1000);
	        }
	    }

	    clearToastMessage() {
	        this.instance.toastMessage.innerHTML = '';
	    }

	    getNoDataHTML() {
	        return ("<div class=\"dt-scrollable__no-data\">" + (this.options.noDataMessage) + "</div>");
	    }

	    getToastMessageHTML(message) {
	        return ("<span class=\"dt-toast__message\">" + message + "</span>");
	    }
	}

	class Style {
	    constructor(instance) {
	        this.instance = instance;

	        linkProperties(this, this.instance, [
	            'options', 'datamanager', 'columnmanager',
	            'header', 'footer', 'bodyScrollable', 'datatableWrapper',
	            'getColumn', 'bodyRenderer'
	        ]);

	        this.scopeClass = 'dt-instance-' + instance.constructor.instances;
	        instance.datatableWrapper.classList.add(this.scopeClass);

	        var styleEl = document.createElement('style');
	        instance.wrapper.insertBefore(styleEl, instance.datatableWrapper);
	        this.styleEl = styleEl;

	        this.bindResizeWindow();
	        this.bindScrollHeader();
	    }

	    get stylesheet() {
	        return this.styleEl.sheet;
	    }

	    bindResizeWindow() {
	        this.onWindowResize = this.onWindowResize.bind(this);
	        this.onWindowResize = throttle$1(this.onWindowResize, 300);

	        if (this.options.layout === 'fluid') {
	            $.on(window, 'resize', this.onWindowResize);
	        }
	    }

	    bindScrollHeader() {
	        var this$1 = this;

	        this._settingHeaderPosition = false;

	        $.on(this.bodyScrollable, 'scroll', function (e) {
	            if (this$1._settingHeaderPosition) { return; }

	            this$1._settingHeaderPosition = true;

	            requestAnimationFrame(function () {
	                var scrollLeft = e.target.scrollLeft;
	                $.style(this$1.header, {
	                    transform: ("translateX(-" + scrollLeft + "px)")
	                });
	                $.style(this$1.footer, {
	                    transform: ("translateX(-" + scrollLeft + "px)")
	                });
	                this$1._settingHeaderPosition = false;
	            });
	        });
	    }

	    onWindowResize() {
	        this.distributeRemainingWidth();
	        this.refreshColumnWidth();
	        this.setBodyStyle();
	    }

	    destroy() {
	        this.styleEl.remove();
	        $.off(window, 'resize', this.onWindowResize);
	    }

	    setStyle(selector, styleObject) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.setStyle(selector, styleObject);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        this._styleRulesMap = this._styleRulesMap || {};
	        var prefixedSelector = this._getPrefixedSelector(selector);

	        if (this._styleRulesMap[prefixedSelector]) {
	            this.removeStyle(selector);

	            // merge with old styleobject
	            styleObject = Object.assign({}, this._styleRulesMap[prefixedSelector], styleObject);
	        }

	        var styleString = this._getRuleString(styleObject);
	        var ruleString = prefixedSelector + " { " + styleString + " }";

	        this._styleRulesMap[prefixedSelector] = styleObject;
	        this.stylesheet.insertRule(ruleString);
	    }

	    removeStyle(selector) {
	        var this$1 = this;

	        if (selector.includes(',')) {
	            selector.split(',')
	                .map(function (s) { return s.trim(); })
	                .forEach(function (selector) {
	                    this$1.removeStyle(selector);
	                });
	            return;
	        }

	        selector = selector.trim();
	        if (!selector) { return; }

	        // find and remove
	        var prefixedSelector = this._getPrefixedSelector(selector);
	        var index = Array.from(this.stylesheet.cssRules)
	            .findIndex(function (rule) { return rule.selectorText === prefixedSelector; });

	        if (index === -1) { return; }
	        this.stylesheet.deleteRule(index);
	    }

	    _getPrefixedSelector(selector) {
	        return ("." + (this.scopeClass) + " " + selector);
	    }

	    _getRuleString(styleObject) {
	        return Object.keys(styleObject)
	            .map(function (prop) {
	                var dashed = prop;
	                if (!prop.includes('-')) {
	                    dashed = camelCaseToDash(prop);
	                }
	                return (dashed + ":" + (styleObject[prop]) + ";");
	            })
	            .join('');
	    }

	    setDimensions() {
	        this.setupMinWidth();
	        this.setupNaturalColumnWidth();
	        this.setupColumnWidth();
	        this.distributeRemainingWidth();
	        this.setColumnStyle();
	        this.setBodyStyle();
	    }

	    setupMinWidth() {
	        var this$1 = this;

	        $.each('.dt-cell--header', this.header).map(function (col) {
	            var ref = $.data(col);
	            var colIndex = ref.colIndex;
	            var column = this$1.getColumn(colIndex);

	            if (!column.minWidth) {
	                var width = $.style($('.dt-cell__content', col), 'width');
	                // only set this once
	                column.minWidth = width;
	            }
	        });
	    }

	    setupNaturalColumnWidth() {
	        var this$1 = this;

	        if (!$('.dt-row')) { return; }

	        $.each('.dt-row-header .dt-cell', this.header).map(function ($headerCell) {
	            var ref = $.data($headerCell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);
	            var width = $.style($('.dt-cell__content', $headerCell), 'width');
	            if (typeof width === 'number' && width >= this$1.options.minimumColumnWidth) {
	                column.naturalWidth = width;
	            } else {
	                column.naturalWidth = this$1.options.minimumColumnWidth;
	            }
	        });

	        // set initial width as naturally calculated by table's first row
	        $.each('.dt-row-0 .dt-cell', this.bodyScrollable).map(function ($cell) {
	            var ref = $.data($cell);
	            var colIndex = ref.colIndex;
	            var column = this$1.datamanager.getColumn(colIndex);

	            var naturalWidth = $.style($('.dt-cell__content', $cell), 'width');

	            if (column.id === '_rowIndex') {
	                naturalWidth = this$1.getRowIndexColumnWidth();
	                column.width = naturalWidth;
	            }

	            if (typeof naturalWidth === 'number' && naturalWidth >= this$1.options.minimumColumnWidth) {
	                column.naturalWidth = naturalWidth;
	            } else {
	                column.naturalWidth = this$1.options.minimumColumnWidth;
	            }
	        });
	    }

	    setupColumnWidth() {
	        if (this.options.layout === 'ratio') {
	            var totalWidth = $.style(this.datatableWrapper, 'width');

	            if (this.options.serialNoColumn) {
	                var rowIndexColumn = this.datamanager.getColumnById('_rowIndex');
	                totalWidth = totalWidth - rowIndexColumn.width - 1;
	            }

	            if (this.options.checkboxColumn) {
	                var rowIndexColumn$1 = this.datamanager.getColumnById('_checkbox');
	                totalWidth = totalWidth - rowIndexColumn$1.width - 1;
	            }

	            var totalParts = this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') {
	                        return 0;
	                    }
	                    if (!column.width) {
	                        column.width = 1;
	                    }
	                    column.ratioWidth = parseInt(column.width, 10);
	                    return column.ratioWidth;
	                })
	                .reduce(function (a, c) { return a + c; });

	            var onePart = totalWidth / totalParts;

	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (column.id === '_rowIndex' || column.id === '_checkbox') { return; }
	                    column.width = Math.floor(onePart * column.ratioWidth) - 1;
	                });
	        } else {
	            this.datamanager.getColumns()
	                .map(function (column) {
	                    if (!column.width) {
	                        column.width = column.naturalWidth;
	                    }
	                    if (column.width < column.minWidth) {
	                        column.width = column.minWidth;
	                    }
	                });
	        }
	    }

	    distributeRemainingWidth() {
	        var this$1 = this;

	        if (this.options.layout !== 'fluid') { return; }

	        var wrapperWidth = $.style(this.instance.datatableWrapper, 'width');
	        var firstRowWidth = $.style($('.dt-row', this.bodyScrollable), 'width');
	        var resizableColumns = this.datamanager.getColumns().filter(function (col) { return col.resizable; });
	        var deltaWidth = (wrapperWidth - firstRowWidth) / resizableColumns.length;

	        resizableColumns.map(function (col) {
	            var width = $.style(this$1.getColumnHeaderElement(col.colIndex), 'width');
	            var finalWidth = Math.floor(width + deltaWidth) - 2;

	            this$1.datamanager.updateColumn(col.colIndex, {
	                width: finalWidth
	            });
	        });
	    }

	    setColumnStyle() {
	        var this$1 = this;

	        // align columns
	        this.datamanager.getColumns()
	            .map(function (column) {
	                // alignment
	                if (!column.align) {
	                    column.align = 'left';
	                }
	                if (!['left', 'center', 'right'].includes(column.align)) {
	                    column.align = 'left';
	                }
	                this$1.setStyle((".dt-cell--col-" + (column.colIndex)), {
	                    'text-align': column.align
	                });

	                // width
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    refreshColumnWidth() {
	        var this$1 = this;

	        this.datamanager.getColumns()
	            .map(function (column) {
	                this$1.columnmanager.setColumnHeaderWidth(column.colIndex);
	                this$1.columnmanager.setColumnWidth(column.colIndex);
	            });
	    }

	    setBodyStyle() {
	        var bodyWidth = $.style(this.datatableWrapper, 'width');
	        var firstRow = $('.dt-row', this.bodyScrollable);
	        var rowWidth = $.style(firstRow, 'width');

	        var width = bodyWidth > rowWidth ? rowWidth : bodyWidth;
	        $.style(this.bodyScrollable, {
	            width: width + 'px'
	        });

	        // remove the body height, so that it resets to it's original
	        $.removeStyle(this.bodyScrollable, 'height');

	        // when there are less rows than the container
	        // adapt the container height
	        var bodyHeight = $.getStyle(this.bodyScrollable, 'height');
	        var scrollHeight = (this.bodyRenderer.hyperlist || {})._scrollHeight || Infinity;
	        var hasHorizontalOverflow = $.hasHorizontalOverflow(this.bodyScrollable);

	        var height;

	        if (scrollHeight < bodyHeight) {
	            height = scrollHeight;

	            // account for scrollbar size when
	            // there is horizontal overflow
	            if (hasHorizontalOverflow) {
	                height += $.scrollbarSize();
	            }

	            $.style(this.bodyScrollable, {
	                height: height + 'px'
	            });
	        }

	        var verticalOverflow = this.bodyScrollable.scrollHeight - this.bodyScrollable.offsetHeight;
	        if (verticalOverflow < $.scrollbarSize()) {
	            // if verticalOverflow is less than scrollbar size
	            // then most likely scrollbar is causing the scroll
	            // which is not needed
	            $.style(this.bodyScrollable, {
	                overflowY: 'hidden'
	            });
	        }

	        if (this.options.layout === 'fluid') {
	            $.style(this.bodyScrollable, {
	                overflowX: 'hidden'
	            });
	        }
	    }

	    getColumnHeaderElement(colIndex) {
	        colIndex = +colIndex;
	        if (colIndex < 0) { return null; }
	        return $((".dt-cell--col-" + colIndex), this.header);
	    }

	    getRowIndexColumnWidth() {
	        var rowCount = this.datamanager.getRowCount();
	        var padding = 22;
	        return $.measureTextWidth(rowCount + '') + padding;
	    }
	}

	var KEYCODES = {
	    13: 'enter',
	    91: 'meta',
	    16: 'shift',
	    17: 'ctrl',
	    18: 'alt',
	    37: 'left',
	    38: 'up',
	    39: 'right',
	    40: 'down',
	    9: 'tab',
	    27: 'esc',
	    67: 'c',
	    70: 'f',
	    86: 'v'
	};

	class Keyboard {
	    constructor(element) {
	        this.listeners = {};
	        $.on(element, 'keydown', this.handler.bind(this));
	    }

	    handler(e) {
	        var key = KEYCODES[e.keyCode];

	        if (e.shiftKey && key !== 'shift') {
	            key = 'shift+' + key;
	        }

	        if ((e.ctrlKey && key !== 'ctrl') || (e.metaKey && key !== 'meta')) {
	            key = 'ctrl+' + key;
	        }

	        var listeners = this.listeners[key];

	        if (listeners && listeners.length > 0) {
	            for (var i = 0, list = listeners; i < list.length; i += 1) {
	                var listener = list[i];

	              var preventBubbling = listener(e);
	                if (preventBubbling === undefined || preventBubbling === true) {
	                    e.preventDefault();
	                }
	            }
	        }
	    }

	    on(key, listener) {
	        var this$1 = this;

	        var keys = key.split(',').map(function (k) { return k.trim(); });

	        keys.map(function (key) {
	            this$1.listeners[key] = this$1.listeners[key] || [];
	            this$1.listeners[key].push(listener);
	        });
	    }
	}

	function filterRows(rows, filters) {
	    var filteredRowIndices = [];

	    if (Object.keys(filters).length === 0) {
	        return rows.map(function (row) { return row.meta.rowIndex; });
	    }

	    var loop = function ( colIndex ) {
	        var keyword = filters[colIndex];

	        var filteredRows = filteredRowIndices.length ?
	            filteredRowIndices.map(function (i) { return rows[i]; }) :
	            rows;

	        var cells = filteredRows.map(function (row) { return row[colIndex]; });

	        var filter = guessFilter(keyword);
	        var filterMethod = getFilterMethod(filter);

	        if (filterMethod) {
	            filteredRowIndices = filterMethod(filter.text, cells);
	        } else {
	            filteredRowIndices = cells.map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    for (var colIndex in filters) loop( colIndex );

	    return filteredRowIndices;
	}
	function getFilterMethod(filter) {
	    var stringCompareValue = function (cell) { return String(stripHTML(cell.html || '') || cell.content || '').toLowerCase(); };

	    var numberCompareValue = function (cell) { return parseFloat(cell.content); };

	    var getCompareValues = function (cell, keyword) {
	        if (cell.column.compareValue) {
	            var compareValues = cell.column.compareValue(cell, keyword);
	            if (compareValues && Array.isArray(compareValues)) { return compareValues; }
	        }

	        // check if it can be converted to number
	        var float = numberCompareValue(cell);
	        if (!isNaN(float)) {
	            return [float, keyword];
	        }

	        return [stringCompareValue(cell), keyword];
	    };

	    var filterMethodMap = {
	        contains: function contains(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var hay = stringCompareValue(cell);
	                    var needle = (keyword || '').toLowerCase();
	                    return !needle || hay.includes(needle);
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        greaterThan: function greaterThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue > keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        lessThan: function lessThan(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var ref = getCompareValues(cell, keyword);
	                    var compareValue = ref[0];
	                    var keywordValue = ref[1];
	                    return compareValue < keywordValue;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        equals: function equals(keyword, cells) {
	            return cells
	                .filter(function (cell) {
	                    var value = parseFloat(cell.content);
	                    return value === keyword;
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        },

	        range: function range(rangeValues, cells) {
	            return cells
	                .filter(function (cell) {
	                    var values1 = getCompareValues(cell, rangeValues[0]);
	                    var values2 = getCompareValues(cell, rangeValues[1]);
	                    var value = values1[0];
	                    return value >= values1[1] && value <= values2[1];
	                })
	                .map(function (cell) { return cell.rowIndex; });
	        }
	    };

	    return filterMethodMap[filter.type];
	}

	function guessFilter(keyword) {
	    if ( keyword === void 0 ) keyword = '';

	    if (keyword.length === 0) { return {}; }

	    var compareString = keyword;

	    if (['>', '<', '='].includes(compareString[0])) {
	        compareString = keyword.slice(1);
	    }

	    if (keyword.startsWith('>')) {
	        if (compareString) {
	            return {
	                type: 'greaterThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('<')) {
	        if (compareString) {
	            return {
	                type: 'lessThan',
	                text: compareString.trim()
	            };
	        }
	    }

	    if (keyword.startsWith('=')) {
	        if (isNumber(compareString)) {
	            return {
	                type: 'equals',
	                text: Number(keyword.slice(1).trim())
	            };
	        }
	    }

	    if (keyword.split(':').length === 2) {
	        compareString = keyword.split(':');
	        return {
	            type: 'range',
	            text: compareString.map(function (v) { return v.trim(); })
	        };
	    }

	    return {
	        type: 'contains',
	        text: compareString.toLowerCase()
	    };
	}

	var DEFAULT_OPTIONS = {
	    columns: [],
	    data: [],
	    dropdownButton: icons.chevronDown,
	    headerDropdown: [
	        {
	            label: 'Sort Ascending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'asc');
	            }
	        },
	        {
	            label: 'Sort Descending',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'desc');
	            }
	        },
	        {
	            label: 'Reset sorting',
	            action: function (column) {
	                this.sortColumn(column.colIndex, 'none');
	            }
	        },
	        {
	            label: 'Remove column',
	            action: function (column) {
	                this.removeColumn(column.colIndex);
	            }
	        }
	    ],
	    events: {
	        onRemoveColumn: function onRemoveColumn(column) {},
	        onSwitchColumn: function onSwitchColumn(column1, column2) {},
	        onSortColumn: function onSortColumn(column) {},
	        onCheckRow: function onCheckRow(row) {},
	        onDestroy: function onDestroy() {}
	    },
	    sortIndicator: {
	        asc: '↑',
	        desc: '↓',
	        none: ''
	    },
	    filterRows: filterRows,
	    freezeMessage: '',
	    getEditor: null,
	    serialNoColumn: true,
	    checkboxColumn: false,
	    clusterize: true,
	    logs: false,
	    layout: 'fixed', // fixed, fluid, ratio
	    noDataMessage: 'No Data',
	    cellHeight: 40,
	    minimumColumnWidth: 70,
	    inlineFilters: false,
	    treeView: false,
	    checkedRowStatus: true,
	    dynamicRowHeight: false,
	    pasteFromClipboard: false,
	    showTotalRow: false
	};

	class DataTable {
	    constructor(wrapper, options) {
	        DataTable.instances++;

	        if (typeof wrapper === 'string') {
	            // css selector
	            wrapper = document.querySelector(wrapper);
	        }
	        this.wrapper = wrapper;
	        if (!(this.wrapper instanceof HTMLElement)) {
	            throw new Error('Invalid argument given for `wrapper`');
	        }

	        this.buildOptions(options);
	        this.prepare();

	        this.style = new Style(this);
	        this.keyboard = new Keyboard(this.wrapper);
	        this.datamanager = new DataManager(this.options);
	        this.rowmanager = new RowManager(this);
	        this.columnmanager = new ColumnManager(this);
	        this.cellmanager = new CellManager(this);
	        this.bodyRenderer = new BodyRenderer(this);

	        if (this.options.data) {
	            this.refresh();
	            this.columnmanager.applyDefaultSortOrder();
	        }
	    }

	    buildOptions(options) {
	        this.options = this.options || {};

	        this.options = Object.assign(
	            {}, DEFAULT_OPTIONS,
	            this.options || {}, options
	        );

	        options.headerDropdown = options.headerDropdown || [];
	        this.options.headerDropdown = DEFAULT_OPTIONS.headerDropdown.concat( options.headerDropdown
	        );

	        // custom user events
	        this.events = Object.assign(
	            {}, DEFAULT_OPTIONS.events,
	            this.options.events || {},
	            options.events || {}
	        );
	        this.fireEvent = this.fireEvent.bind(this);
	    }

	    prepare() {
	        this.prepareDom();
	        this.unfreeze();
	    }

	    prepareDom() {
	        this.wrapper.innerHTML = "\n            <div class=\"datatable\">\n                <div class=\"dt-header\"></div>\n                <div class=\"dt-scrollable\"></div>\n                <div class=\"dt-footer\"></div>\n                <div class=\"dt-freeze\">\n                    <span class=\"dt-freeze__message\">\n                        " + (this.options.freezeMessage) + "\n                    </span>\n                </div>\n                <div class=\"dt-toast\"></div>\n                <div class=\"dt-dropdown-container\"></div>\n                <textarea class=\"dt-paste-target\"></textarea>\n            </div>\n        ";

	        this.datatableWrapper = $('.datatable', this.wrapper);
	        this.header = $('.dt-header', this.wrapper);
	        this.footer = $('.dt-footer', this.wrapper);
	        this.bodyScrollable = $('.dt-scrollable', this.wrapper);
	        this.freezeContainer = $('.dt-freeze', this.wrapper);
	        this.toastMessage = $('.dt-toast', this.wrapper);
	        this.pasteTarget = $('.dt-paste-target', this.wrapper);
	        this.dropdownContainer = $('.dt-dropdown-container', this.wrapper);
	    }

	    refresh(data, columns) {
	        this.datamanager.init(data, columns);
	        this.render();
	        this.setDimensions();
	    }

	    destroy() {
	        this.wrapper.innerHTML = '';
	        this.style.destroy();
	        this.fireEvent('onDestroy');
	    }

	    appendRows(rows) {
	        this.datamanager.appendRows(rows);
	        this.rowmanager.refreshRows();
	    }

	    refreshRow(row, rowIndex) {
	        this.rowmanager.refreshRow(row, rowIndex);
	    }

	    render() {
	        this.renderHeader();
	        this.renderBody();
	    }

	    renderHeader() {
	        this.columnmanager.renderHeader();
	    }

	    renderBody() {
	        this.bodyRenderer.render();
	    }

	    setDimensions() {
	        this.style.setDimensions();
	    }

	    showToastMessage(message, hideAfter) {
	        this.bodyRenderer.showToastMessage(message, hideAfter);
	    }

	    clearToastMessage() {
	        this.bodyRenderer.clearToastMessage();
	    }

	    getColumn(colIndex) {
	        return this.datamanager.getColumn(colIndex);
	    }

	    getColumns() {
	        return this.datamanager.getColumns();
	    }

	    getRows() {
	        return this.datamanager.getRows();
	    }

	    getCell(colIndex, rowIndex) {
	        return this.datamanager.getCell(colIndex, rowIndex);
	    }

	    getColumnHeaderElement(colIndex) {
	        return this.columnmanager.getColumnHeaderElement(colIndex);
	    }

	    getViewportHeight() {
	        if (!this.viewportHeight) {
	            this.viewportHeight = $.style(this.bodyScrollable, 'height');
	        }

	        return this.viewportHeight;
	    }

	    sortColumn(colIndex, sortOrder) {
	        this.columnmanager.sortColumn(colIndex, sortOrder);
	    }

	    removeColumn(colIndex) {
	        this.columnmanager.removeColumn(colIndex);
	    }

	    scrollToLastColumn() {
	        this.datatableWrapper.scrollLeft = 9999;
	    }

	    freeze() {
	        $.style(this.freezeContainer, {
	            display: ''
	        });
	    }

	    unfreeze() {
	        $.style(this.freezeContainer, {
	            display: 'none'
	        });
	    }

	    updateOptions(options) {
	        this.buildOptions(options);
	    }

	    fireEvent(eventName) {
	        var this$1 = this;
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        // fire internalEventHandlers if any
	        // and then user events
	        var handlers = (this._internalEventHandlers[eventName] || []).concat( [this.events[eventName]]
	        ).filter(Boolean);

	        for (var i = 0, list = handlers; i < list.length; i += 1) {
	            var handler = list[i];

	          handler.apply(this$1, args);
	        }
	    }

	    on(event, handler) {
	        this._internalEventHandlers = this._internalEventHandlers || {};
	        this._internalEventHandlers[event] = this._internalEventHandlers[event] || [];
	        this._internalEventHandlers[event].push(handler);
	    }

	    log() {
	        if (this.options.logs) {
	            console.log.apply(console, arguments);
	        }
	    }
	}

	DataTable.instances = 0;

	var name = "frappe-datatable";
	var version = "0.0.0-development";
	var description = "A modern datatable library for the web";
	var main = "dist/frappe-datatable.cjs.js";
	var unpkg = "dist/frappe-datatable.min.js";
	var jsdelivr = "dist/frappe-datatable.min.js";
	var scripts = {"start":"yarn run dev","build":"rollup -c && NODE_ENV=production rollup -c","dev":"rollup -c -w","cy:server":"http-server -p 8989","cy:open":"cypress open","cy:run":"cypress run","test":"start-server-and-test cy:server http://localhost:8989 cy:run","test-local":"start-server-and-test cy:server http://localhost:8989 cy:open","travis-deploy-once":"travis-deploy-once","semantic-release":"semantic-release","lint":"eslint src","commit":"npx git-cz"};
	var files = ["dist","src"];
	var devDependencies = {"autoprefixer":"^9.0.0","chai":"3.5.0","cypress":"3.0.1","cz-conventional-changelog":"^2.1.0","deepmerge":"^2.0.1","eslint":"^5.0.1","eslint-config-airbnb":"^16.1.0","eslint-config-airbnb-base":"^12.1.0","eslint-plugin-import":"^2.11.0","http-server":"^0.11.1","mocha":"3.3.0","postcss-custom-properties":"^7.0.0","postcss-nested":"^3.0.0","rollup":"^0.59.4","rollup-plugin-commonjs":"^8.3.0","rollup-plugin-eslint":"^4.0.0","rollup-plugin-json":"^2.3.0","rollup-plugin-node-resolve":"^3.0.3","rollup-plugin-postcss":"^1.2.8","rollup-plugin-uglify-es":"^0.0.1","semantic-release":"^15.6.3","start-server-and-test":"^1.4.1","travis-deploy-once":"^5.0.1"};
	var repository = {"type":"git","url":"https://github.com/frappe/datatable.git"};
	var keywords = ["datatable","data","grid","table"];
	var author = "Faris Ansari";
	var license = "MIT";
	var bugs = {"url":"https://github.com/frappe/datatable/issues"};
	var homepage = "https://frappe.github.io/datatable";
	var dependencies = {"hyperlist":"^1.0.0-beta","lodash":"^4.17.5","sortablejs":"^1.7.0"};
	var config = {"commitizen":{"path":"cz-conventional-changelog"}};
	var packageJson = {
		name: name,
		version: version,
		description: description,
		main: main,
		unpkg: unpkg,
		jsdelivr: jsdelivr,
		scripts: scripts,
		files: files,
		devDependencies: devDependencies,
		repository: repository,
		keywords: keywords,
		author: author,
		license: license,
		bugs: bugs,
		homepage: homepage,
		dependencies: dependencies,
		config: config
	};

	DataTable.__version__ = packageJson.version;

	module.exports = DataTable;
	});

	var DataTable = unwrapExports(frappeDatatable_cjs);

	/**
	 * frappe.views.ReportView
	 */

	frappe.provide('frappe.views');

	frappe.views.ReportView = class ReportView extends frappe.views.ListView {
		get view_name() {
			return 'Report';
		}

		setup_defaults() {
			var this$1 = this;

			super.setup_defaults();
			this.page_title = __('Report:') + ' ' + this.page_title;
			this.menu_items = this.report_menu_items();

			var route = frappe.get_route();
			if (route.length === 4) {
				this.report_name = route[3];
			}

			this.add_totals_row = this.view_user_settings.add_totals_row || 0;

			if (this.report_name) {
				return this.get_report_doc()
					.then(function (doc) {
						this$1.report_doc = doc;
						this$1.report_doc.json = JSON.parse(this$1.report_doc.json);

						this$1.filters = this$1.report_doc.json.filters;
						this$1.order_by = this$1.report_doc.json.order_by;
						this$1.add_totals_row = this$1.report_doc.json.add_totals_row;
						this$1.page_title = this$1.report_name;
						this$1.page_length = this$1.report_doc.json.page_length || 20;
						this$1.order_by = this$1.report_doc.json.order_by || 'modified desc';
					});
			}
		}

		setup_view() {
			this.setup_columns();
			this.bind_charts_button();
		}

		setup_result_area() {
			super.setup_result_area();
			this.$datatable_wrapper = $('<div class="datatable-wrapper">');
			this.$charts_wrapper = $('<div class="charts-wrapper">');
			this.$result.append(this.$charts_wrapper);
			this.$result.append(this.$datatable_wrapper);
		}

		setup_paging_area() {
			super.setup_paging_area();
			var message = __('For comparison, use >5, <10 or =324. For ranges, use 5:10 (for values between 5 & 10).');
			this.$paging_area.find('.level-left').append(
				("<p class=\"text-muted text-medium margin-left\">" + message + "</p>")
			);
		}

		setup_sort_selector() {
			this.sort_selector = new frappe.ui.SortSelector({
				parent: this.filter_area.$filter_list_wrapper,
				doctype: this.doctype,
				args: this.order_by,
				onchange: this.on_sort_change.bind(this)
			});
		}

		before_render() {
			if (this.report_doc) {
				this.set_dirty_state_for_custom_report();
			} else {
				this.save_report_settings();
			}
		}

		set_dirty_state_for_custom_report() {
			var json = JSON.stringify({
				filters: this.filter_area.get(),
				fields: this.fields,
				order_by: this.sort_selector.get_sql_string(),
				add_totals_row: this.add_totals_row,
				page_length: this.page_length
			});

			var report_json = JSON.stringify({
				filters: this.report_doc.json.filters,
				fields: this.report_doc.json.fields,
				order_by: this.report_doc.json.order_by,
				add_totals_row: this.report_doc.json.add_totals_row,
				page_length: this.report_doc.json.page_length
			});

			if (json != report_json) {
				this.page.set_indicator(__('Not Saved'), 'orange');
			} else {
				this.page.clear_indicator();
			}
		}

		save_report_settings() {
			frappe.model.user_settings.save(this.doctype, 'last_view', this.view_name);

			if (!this.report_name) {
				this.save_view_user_settings({
					fields: this.fields,
					filters: this.filter_area.get(),
					order_by: this.sort_selector.get_sql_string(),
					add_totals_row: this.add_totals_row
				});
			}
		}

		prepare_data(r) {
			var data = r.message || {};
			data = frappe.utils.dict(data.keys, data.values);

			if (this.start === 0) {
				this.data = data;
			} else {
				this.data = this.data.concat(data);
			}
		}

		render(force) {
			if (this.data.length === 0) { return; }
			this.render_count();

			if (this.chart) {
				this.refresh_charts();
			}
			if (this.datatable && !force) {
				this.datatable.refresh(this.get_data(this.data), this.columns);
				return;
			}
			this.setup_datatable(this.data);
		}

		render_count() {
			var $list_count = this.$paging_area.find('.list-count');
			if (!$list_count.length) {
				this.$paging_area.find('.btn-more').addClass('margin-left');
				$list_count = $('<span>')
					.addClass('text-muted text-medium list-count')
					.prependTo(this.$paging_area.find('.level-right'));
			}
			this.get_count_str()
				.then(function (str) {
					$list_count.text(str);
				});
		}

		on_update(data) {
			var this$1 = this;

			if (this.doctype === data.doctype && data.name) {
				// flash row when doc is updated by some other user
				var flash_row = data.user !== frappe.session.user;
				if (this.data.find(function (d) { return d.name === data.name; })) {
					// update existing
					frappe.db.get_doc(data.doctype, data.name)
						.then(function (doc) { return this$1.update_row(doc, flash_row); });
				} else {
					// refresh
					this.refresh();
				}
			}
		}

		update_row(doc, flash_row) {
			var this$1 = this;

			var to_refresh = [];

			this.data = this.data.map(function (d, i) {
				if (d.name === doc.name) {
					for (var fieldname in d) {
						if (fieldname.includes(':')) {
							// child table field
							var ref = fieldname.split(':');
							var cdt = ref[0];
							var _field = ref[1];
							var cdt_row = Object.keys(doc)
								.filter(function (key) { return Array.isArray(doc[key]) && doc[key][0].doctype === cdt; })
								.map(function (key) { return doc[key]; })
								.map(function (a) { return a[0]; })
								.filter(function (cdoc) { return cdoc.name === d[cdt + ':name']; })[0];
							if (cdt_row) {
								d[fieldname] = cdt_row[_field];
							}
						} else {
							d[fieldname] = doc[fieldname];
						}
					}
					to_refresh.push([d, i]);
				}
				return d;
			});

			// indicate row update
			var _flash_row = function (rowIndex) {
				if (!flash_row) { return; }
				var $row = this$1.$result.find((".dt-row[data-row-index=\"" + rowIndex + "\"]"));
				$row.addClass('row-update');
				setTimeout(function () { return $row.removeClass('row-update'); }, 500);
			};

			to_refresh.forEach(function (ref) {
				var data = ref[0];
				var rowIndex = ref[1];

				var new_row = this$1.build_row(data);
				this$1.datatable.refreshRow(new_row, rowIndex);
				_flash_row(rowIndex);
			});
		}

		setup_datatable(values) {
			var this$1 = this;

			this.$datatable_wrapper.empty();
			this.datatable = new DataTable(this.$datatable_wrapper[0], {
				columns: this.columns,
				data: this.get_data(values),
				getEditor: this.get_editing_object.bind(this),
				checkboxColumn: true,
				inlineFilters: true,
				cellHeight: 37,
				events: {
					onRemoveColumn: function (column) {
						this$1.remove_column_from_datatable(column);
					},
					onSwitchColumn: function (column1, column2) {
						this$1.switch_column(column1, column2);
					},
					onCheckRow: function () {
						var checked_items = this$1.get_checked_items();
						this$1.toggle_actions_menu_button(checked_items.length > 0);
					}
				},
				hooks: {
					totalAccumulator: frappe.utils.report_total_accumulator
				},
				headerDropdown: [{
					label: __('Add Column'),
					action: function (datatabe_col) {
						var columns_in_picker = [];
						var columns = this$1.get_columns_for_picker();

						columns_in_picker = columns[this$1.doctype]
							.filter(function (df) { return !this$1.is_column_added(df); })
							.map(function (df) { return ({
								label: __(df.label),
								value: df.fieldname
							}); });

						delete columns[this$1.doctype];

						var loop = function ( cdt ) {
							columns[cdt]
								.filter(function (df) { return !this$1.is_column_added(df); })
								.map(function (df) { return ({
									label: __(df.label) + " (" + cdt + ")",
									value: df.fieldname + ',' + cdt
								}); })
								.forEach(function (df) { return columns_in_picker.push(df); });
						};

						for (var cdt in columns) loop( cdt );

						var d = new frappe.ui.Dialog({
							title: __('Add Column'),
							fields: [
								{
									label: __('Select Column'),
									fieldname: 'column',
									fieldtype: 'Autocomplete',
									options: columns_in_picker
								},
								{
									label: __('Insert Column Before {0}', [datatabe_col.docfield.label.bold()]),
									fieldname: 'insert_before',
									fieldtype: 'Check'
								}
							],
							primary_action: function (ref) {
								var assign;

								var column = ref.column;
								var insert_before = ref.insert_before;
								if (!columns_in_picker.map(function (col) { return col.value; }).includes(column)) {
									frappe.show_alert(__('Invalid column'));
									d.hide();
									return;
								}

								var doctype = this$1.doctype;
								if (column.includes(',')) {
									(assign = column.split(','), column = assign[0], doctype = assign[1]);
								}


								var index = datatabe_col.colIndex;
								if (insert_before) {
									index = index - 1;
								}

								this$1.add_column_to_datatable(column, doctype, index);
								d.hide();
							}
						});

						d.show();
					}
				}]
			});
		}

		bind_charts_button() {
			var this$1 = this;

			this.list_sidebar.sidebar.find('.charts-menu').removeClass('hide');
			this.list_sidebar.sidebar.on('click', '.toggle-charts', function (e) {
				e.preventDefault();
				this$1.toggle_charts();
			});
			this.list_sidebar.sidebar.on('click', '.configure-charts', function (e) {
				e.preventDefault();
				this$1.get_chart_data().then(function () { return this$1.refresh_charts(); });
			});
			this.refresh_charts_sidebar_button();
		}

		refresh_charts_sidebar_button() {
			// show configure charts button if charts is shown
			var $configure_btn = this.list_sidebar.sidebar.find('.configure-charts');
			var charts_visible = this.chart && !this.$charts_wrapper.hasClass('hidden');

			if (charts_visible) {
				$configure_btn.removeClass('hidden');
			} else {
				$configure_btn.addClass('hidden');
			}
		}

		toggle_charts() {
			if (!this.chart) {
				this.setup_charts();
				return;
			}
			this.$charts_wrapper.toggleClass('hidden');

			if (!this.$charts_wrapper.hasClass('hidden')) {
				this.chart.refresh();
			}

			this.refresh_charts_sidebar_button();
		}

		setup_charts() {
			var this$1 = this;

			this.get_chart_data()
				.then(function (args) {
					var data = {
						labels: args.labels,
						datasets: args.datasets
					};

					this$1.last_chart_type = args.chart_type;

					var get_df = function (field) { return frappe.meta.get_docfield(this$1.doctype, field); };
					var get_doc = function (value, field) { return this$1.data.find(function (d) { return d[field] === value; }); };

					this$1.chart = new Chart(this$1.$charts_wrapper[0], {
						title: __("{0} Chart", [this$1.doctype]),
						data: data,
						type: args.chart_type,
						height: 150,
						colors: ['violet', 'light-blue', 'orange', 'red'],

						format_tooltip_x: function (value) { return value.doc.name; },
						format_tooltip_y:
							function (value) { return frappe.format(value, get_df(value.field), { always_show_decimals: true, inline: true }, get_doc(value.doc)); }
					});

					this$1.refresh_charts_sidebar_button();
				});
		}

		refresh_charts() {
			if (!this.chart) { return; }
			var ref = this.chart_args;
			var x_field = ref.x_field;
			var y_fields = ref.y_fields;
			var chart_type = ref.chart_type;
			var args = this.get_chart_args(x_field, y_fields, chart_type);
			this.chart.update_values(args.datasets, args.labels);
			this.chart.refresh();

			if (args.chart_type !== this.last_chart_type) {
				this.chart.get_different_chart(args.chart_type);
			}
		}

		get_chart_data() {
			var this$1 = this;

			return new Promise(function (resolve) {
				var cur_list_fields = this$1.fields.map(function (f) { return f[0]; });
				var x_fields = this$1.meta.fields.filter(function (df) { return !df.hidden && cur_list_fields.includes(df.fieldname); }
				).map(function (df) { return df.fieldname; });
				var y_fields = this$1.meta.fields.filter(function (df) { return !df.hidden && frappe.model.is_numeric_field(df)
					&& cur_list_fields.includes(df.fieldname); }
				).map(function (df) { return df.fieldname; });

				var defaults = this$1.chart_args || {};

				var dialog = new frappe.ui.Dialog({
					title: __('Configure Chart'),
					fields: [
						{
							label: __('X Axis Field'),
							fieldtype: 'Autocomplete',
							fieldname: 'x_axis',
							options: x_fields,
							default: defaults.x_field
						},
						{
							label: __('Y Axis Fields'),
							fieldtype: 'MultiSelect',
							fieldname: 'y_axes',
							options: y_fields,
							description: __('Showing only Numeric fields from Report'),
							default: defaults.y_fields
						},
						{
							label: __('Chart Type'),
							fieldtype: 'Select',
							options: ['Bar', 'Line', 'Pie', 'Percentage'],
							fieldname: 'chart_type',
							default: toTitle(defaults.chart_type || 'Bar')
						}
					],
					primary_action: function (ref) {
						var x_axis = ref.x_axis;
						var y_axes = ref.y_axes;
						var chart_type = ref.chart_type;

						y_axes = y_axes.split(',').map(function (d) { return d.trim(); }).filter(Boolean);

						if (!(
							y_axes.every(function (d) { return y_fields.includes(d); })
							&& x_fields.includes(x_axis)
						)) { return; }

						var args = this$1.get_chart_args(x_axis, y_axes, chart_type);
						this$1.chart_args = args;
						resolve(args);
						dialog.hide();
					}
				});

				dialog.show();
			});
		}

		get_chart_args(x_axis, y_axes, chart_type) {
			var this$1 = this;

			var labels = this.data.map(function (d) {
				// HACK: labels need strings,
				// so we return objects that
				// look like strings and also
				// monkey patch the doc
				// javascript is awesome

				// O.o

				return {
					doc: d,
					toString: function toString() {
						return d[x_axis];
					},
					slice: String.prototype.slice
				};
			});

			return {
				chart_type: chart_type.toLowerCase(),
				x_field: x_axis,
				y_fields: y_axes,
				labels: labels,
				datasets: y_axes.map(function (y_axis) { return ({
					name: frappe.meta.get_docfield(this$1.doctype, y_axis).label,
					values: this$1.data.map(function (d) { return ({
						doc: d,
						field: y_axis,
						toString: function toString() {
							return d[y_axis];
						},
						slice: String.prototype.slice
					}); })
				}); })
			};
		}

		get_editing_object(colIndex, rowIndex, value, parent) {
			var this$1 = this;

			var control = this.render_editing_input(colIndex, value, parent);
			if (!control) { return false; }

			control.df.change = function () { return control.set_focus(); };

			return {
				initValue: function (value) {
					return control.set_value(value);
				},
				setValue: function (value) {
					var cell = this$1.datatable.getCell(colIndex, rowIndex);
					var fieldname = this$1.datatable.getColumn(colIndex).docfield.fieldname;
					var docname = cell.name;
					var doctype = cell.doctype;

					control.set_value(value);
					return this$1.set_control_value(doctype, docname, fieldname, value)
						.then(function (updated_doc) {
							var _data = this$1.data.find(function (d) { return d.name === updated_doc.name; });
							for (var field in _data) {
								_data[field] = updated_doc[field];
							}
						})
						.then(function () { return this$1.refresh_charts(); });
				},
				getValue: function () {
					return control.get_value();
				}
			};
		}

		set_control_value(doctype, docname, fieldname, value) {
			this.last_updated_doc = docname;
			return new Promise(function (resolve, reject) {
				var obj;

				frappe.db.set_value(doctype, docname, ( obj = {}, obj[fieldname] = value, obj ))
					.then(function (r) {
						if (r.message) {
							resolve(r.message);
						} else {
							reject();
						}
					})
					.fail(reject);
			});
		}

		render_editing_input(colIndex, value, parent) {
			var this$1 = this;

			var col = this.datatable.getColumn(colIndex);
			var control = null;

			if (col.docfield.fieldtype === 'Text Editor') {
				var d = new frappe.ui.Dialog({
					title: __('Edit {0}', [col.docfield.label]),
					fields: [col.docfield],
					primary_action: function () {
						this$1.datatable.cellmanager.submitEditing();
						this$1.datatable.cellmanager.deactivateEditing();
						d.hide();
					}
				});
				d.show();
				control = d.fields_dict[col.docfield.fieldname];
			} else {
				// make control
				control = frappe.ui.form.make_control({
					df: col.docfield,
					parent: parent,
					render_input: true
				});
				control.set_value(value);
				control.toggle_label(false);
				control.toggle_description(false);
			}

			return control;
		}

		is_editable(df, data) {
			if (!df || data.docstatus !== 0) { return false; }
			var is_standard_field = frappe.model.std_fields_list.includes(df.fieldname);
			var can_edit = !(
				is_standard_field
				|| df.read_only
				|| df.hidden
				|| !frappe.model.can_write(this.doctype)
			);
			return can_edit;
		}

		get_data(values) {
			return this.build_rows(values);
		}

		set_fields() {
			var this$1 = this;

			if (this.report_name && this.report_doc.json.fields) {
				this.fields = this.report_doc.json.fields.slice();
				return;
			} else if (this.view_user_settings.fields) {
				// get from user_settings
				this.fields = this.view_user_settings.fields;
				return;
			}

			// get fields from meta
			this.fields = [];
			var add_field = function (f) { return this$1._add_field(f); };

			// default fields
			[
				'name', 'docstatus',
				this.meta.title_field,
				this.meta.image_field
			].map(add_field);

			// fields in_list_view or in_standard_filter
			var fields = this.meta.fields.filter(function (df) {
				return (df.in_list_view || df.in_standard_filter)
					&& frappe.perm.has_perm(this$1.doctype, df.permlevel, 'read')
					&& frappe.model.is_value_type(df.fieldtype)
					&& !df.report_hide;
			});

			fields.map(add_field);

			// currency fields
			fields.filter(
				function (df) { return df.fieldtype === 'Currency' && df.options; }
			).map(function (df) {
				if (df.options.includes(':')) {
					add_field(df.options.split(':')[1]);
				} else {
					add_field(df.options);
				}
			});

			// fields in listview_settings
			(this.settings.add_fields || []).map(add_field);
		}

		build_fields() {
			this.fields.push(['docstatus', this.doctype]);
			super.build_fields();
		}

		get_fields() {
			var this$1 = this;

			var fields = this.fields.map(function (f) {
				var column_name = frappe.model.get_full_column_name(f[0], f[1]);
				if (f[1] !== this$1.doctype) {
					// child table field
					column_name = column_name + ' as ' + "'" + (f[1]) + ":" + (f[0]) + "'";
				}
				return column_name;
			});
			var cdt_name_fields =
				this.get_unique_cdt_in_view()
					.map(function (cdt) { return frappe.model.get_full_column_name('name', cdt) + ' as ' + "'" + cdt + ":name'"; });
			fields = fields.concat(cdt_name_fields);

			return fields;
		}

		get_unique_cdt_in_view() {
			var this$1 = this;

			return this.fields
				.filter(function (f) { return f[1] !== this$1.doctype; })
				.map(function (f) { return f[1]; })
				.uniqBy(function (d) { return d; });
		}

		add_column_to_datatable(fieldname, doctype, col_index) {
			var field = [fieldname, doctype];
			this.fields.splice(col_index, 0, field);

			this.add_currency_column(fieldname, doctype, col_index);

			this.build_fields();
			this.setup_columns();

			this.datatable.destroy();
			this.datatable = null;
			this.refresh();
		}

		add_currency_column(fieldname, doctype, col_index) {
			// Adds dependent currency field if required
			var df = frappe.meta.get_docfield(doctype, fieldname);
			if (df && df.fieldtype === 'Currency' && df.options &&
				!df.options.includes(':') && frappe.meta.has_field(doctype, df.options)
			) {
				var field = [df.options, doctype];
				if (col_index === undefined) {
					this.fields.push(field);
				} else {
					this.fields.splice(col_index, 0, field);
				}
				frappe.show_alert(__('Also adding the dependent currency field {0}', [field[0].bold()]));
			}
		}

		remove_column_from_datatable(column) {
			var index = this.fields.findIndex(function (f) { return column.field === f[0]; });
			if (index === -1) { return; }
			var field = this.fields[index];
			if (field[0] === 'name') {
				this.refresh();
				frappe.throw(__('Cannot remove ID field'));
			}
			this.fields.splice(index, 1);
			this.build_fields();
			this.setup_columns();
			this.refresh();
		}

		switch_column(col1, col2) {
			var index1 = this.fields.findIndex(function (f) { return col1.field === f[0]; });
			var index2 = this.fields.findIndex(function (f) { return col2.field === f[0]; });
			var _fields = this.fields.slice();

			var temp = _fields[index1];
			_fields[index1] = _fields[index2];
			_fields[index2] = temp;

			this.fields = _fields;
			this.build_fields();
			this.setup_columns();
			this.refresh();
		}

		get_columns_for_picker() {
			var out = {};

			var standard_fields_filter = function (df) { return !in_list(frappe.model.no_value_type, df.fieldtype) &&
				!df.report_hide && df.fieldname !== 'naming_series' &&
				!df.hidden; };

			var doctype_fields = frappe.meta.get_docfields(this.doctype).filter(standard_fields_filter);

			doctype_fields = [{
				label: __('ID'),
				fieldname: 'name',
				fieldtype: 'Data'
			}].concat(doctype_fields, frappe.model.std_fields);

			out[this.doctype] = doctype_fields;

			var table_fields = frappe.meta.get_table_fields(this.doctype)
				.filter(function (df) { return !df.hidden; });

			table_fields.forEach(function (df) {
				var cdt = df.options;
				var child_table_fields = frappe.meta.get_docfields(cdt).filter(standard_fields_filter);

				out[cdt] = child_table_fields;
			});

			return out;
		}

		get_dialog_fields() {
			var this$1 = this;

			var dialog_fields = [];
			var columns = this.get_columns_for_picker();

			dialog_fields.push({
				label: __(this.doctype),
				fieldname: this.doctype,
				fieldtype: 'MultiCheck',
				columns: 2,
				options: columns[this.doctype]
					.map(function (df) { return ({
						label: __(df.label),
						value: df.fieldname,
						checked: this$1.fields.find(function (f) { return f[0] === df.fieldname; })
					}); })
			});

			delete columns[this.doctype];

			var table_fields = frappe.meta.get_table_fields(this.doctype)
				.filter(function (df) { return !df.hidden; });

			table_fields.forEach(function (df) {
				var cdt = df.options;

				dialog_fields.push({
					label: __(df.label) + " (" + (__(cdt)) + ")",
					fieldname: df.options,
					fieldtype: 'MultiCheck',
					columns: 2,
					options: columns[cdt]
						.map(function (df) { return ({
							label: __(df.label),
							value: df.fieldname,
							checked: this$1.fields.find(function (f) { return f[0] === df.fieldname && f[1] === cdt; })
						}); })
				});
			});

			return dialog_fields;
		}

		is_column_added(df) {
			return Boolean(
				this.fields.find(function (f) { return f[0] === df.fieldname && df.parent === f[1]; })
			);
		}

		setup_columns() {
			var this$1 = this;

			var hide_columns = ['docstatus'];
			var fields = this.fields.filter(function (f) { return !hide_columns.includes(f[0]); });
			this.columns = fields.map(function (f) { return this$1.build_column(f); }).filter(Boolean);
		}

		build_column(c) {
			var fieldname = c[0];
			var doctype = c[1];
			var docfield = frappe.meta.docfield_map[doctype || this.doctype][fieldname];

			if (!docfield) {
				docfield = frappe.model.get_std_field(fieldname);

				if (docfield) {
					docfield.parent = this.doctype;
					if (fieldname == "name") {
						docfield.options = this.doctype;
					}
				}
			}
			if (!docfield) { return; }

			var title = __(docfield ? docfield.label : toTitle(fieldname));
			if (doctype !== this.doctype) {
				title += " (" + (__(doctype)) + ")";
			}

			var editable = frappe.model.is_non_std_field(fieldname) && !docfield.read_only;

			var align = (function () {
				var is_numeric = frappe.model.is_numeric_field(docfield);
				if (is_numeric) {
					return 'right';
				}
				return docfield.fieldtype === 'Date' ? 'right' : 'left';
			})();

			var width = (docfield ? cint(docfield.width) : null) || null;

			// child table column
			var id = doctype !== this.doctype ? (doctype + ":" + fieldname) : fieldname;

			var compareFn = null;
			if (docfield.fieldtype === 'Date') {
				compareFn = function (cell, keyword) {
					if (!cell.content) { return null; }
					if (keyword.length !== 'YYYY-MM-DD'.length) { return null; }

					var keywordValue = frappe.datetime.user_to_obj(keyword);
					var cellValue = frappe.datetime.str_to_obj(cell.content);
					return [+cellValue, +keywordValue];
				};
			}


			return {
				id: id,
				field: fieldname,
				name: title,
				content: title,
				docfield: docfield,
				width: width,
				editable: editable,
				align: align,
				compareValue: compareFn,
				format: function (value, row, column, data) {
					var d = row.reduce(function (acc, curr) {
						if (!curr.column.docfield) { return acc; }
						acc[curr.column.docfield.fieldname] = curr.content;
						return acc;
					}, {});

					return frappe.format(value, column.docfield, { always_show_decimals: true }, d);
				}
			};
		}

		build_rows(data) {
			var this$1 = this;

			var out = data.map(function (d) { return this$1.build_row(d); });

			if (this.add_totals_row) {
				var totals = this.get_columns_totals(data);
				var totals_row = this.columns.map(function (col, i) {
					return {
						name: __('Totals Row'),
						content: totals[col.id],
						format: function (value) {
							return frappe.format(value, col.docfield, { always_show_decimals: true });
						}
					}
				});

				totals_row[0].content = __('Totals').bold();
				out.push(totals_row);
			}

			return out;
		}

		build_row(d) {
			var this$1 = this;

			return this.columns.map(function (col) {
				if (col.docfield.parent !== this$1.doctype) {
					// child table field
					var cdt_field = function (f) { return ((col.docfield.parent) + ":" + f); };
					var name = d[cdt_field('name')];

					return {
						name: name,
						doctype: col.docfield.parent,
						content: d[cdt_field(col.field)],
						editable: Boolean(name && this$1.is_editable(col.docfield, d)),
						format: function (value) {
							return frappe.format(value, col.docfield, { always_show_decimals: true });
						}
					};
				}

				if (col.field in d) {
					var value = d[col.field];
					return {
						name: d.name,
						doctype: col.docfield.parent,
						content: value,
						editable: this$1.is_editable(col.docfield, d)
					};
				}
				return {
					content: ''
				};
			});
		}

		get_checked_items(only_docnames) {
			var this$1 = this;

			var indexes = this.datatable.rowmanager.getCheckedRows();
			var items = indexes.filter(function (i) { return i != undefined; })
				.map(function (i) { return this$1.data[i]; });

			if (only_docnames) {
				return items.map(function (d) { return d.name; });
			}

			return items;
		}

		save_report(save_type) {
			var this$1 = this;

			var _save_report = function (name) {
				// callback
				var report_settings = {
					filters: this$1.filter_area.get(),
					fields: this$1.fields,
					order_by: this$1.sort_selector.get_sql_string(),
					add_totals_row: this$1.add_totals_row,
					page_length: this$1.page_length
				};

				return frappe.call({
					method: 'frappe.desk.reportview.save_report',
					args: {
						name: name,
						doctype: this$1.doctype,
						json: JSON.stringify(report_settings)
					},
					callback:function (r) {
						if(r.exc) {
							frappe.msgprint(__("Report was not saved (there were errors)"));
							return;
						}
						if(r.message != this$1.report_name) {
							// Rerender the reports dropdown,
							// so that this report is included in the dropdown as well.
							frappe.boot.user.all_reports[r.message] = {
								ref_doctype: "Item",
								report_type: "Report Builder",
								title: r.message,
							};
							this$1.list_sidebar.setup_reports();
							frappe.set_route('List', this$1.doctype, 'Report', r.message);
						}

						// update state
						this$1.report_doc.json = report_settings;
						this$1.set_dirty_state_for_custom_report();
					}
				});

			};

			if(this.report_name && save_type == "save") {
				_save_report(this.report_name);
			} else {
				frappe.prompt({fieldname: 'name', label: __('New Report name'), reqd: 1, fieldtype: 'Data'}, function (data) {
					_save_report(data.name);
				}, __('Save As'));
			}
		}

		get_report_doc() {
			var this$1 = this;

			return new Promise(function (resolve) {
				frappe.model.with_doc('Report', this$1.report_name, function () {
					resolve(frappe.get_doc('Report', this$1.report_name));
				});
			});
		}

		get_filters_html_for_print() {
			var filters = this.filter_area.get();

			return filters.map(function (f) {
				var doctype = f[0];
				var fieldname = f[1];
				var condition = f[2];
				var value = f[3];
				if (condition !== '=') { return ''; }

				var label = frappe.meta.get_label(doctype, fieldname);
				return ("<h6>" + (__(label)) + ": " + value + "</h6>");
			}).join('');
		}

		get_columns_totals(data) {
			if (!this.add_totals_row) {
				return [];
			}

			var row_totals = {};

			this.columns.forEach(function (col, i) {
				var totals = data.reduce(function (totals, d) {
					if (col.id in d && frappe.model.is_numeric_field(col.docfield)) {
						totals += flt(d[col.id]);
						return totals;
					}
				}, 0);

				row_totals[col.id] = totals;
			});

			return row_totals;
		}

		report_menu_items() {
			var this$1 = this;

			var items = [
				{
					label: __('Show Totals'),
					action: function () {
						this$1.add_totals_row = !this$1.add_totals_row;
						this$1.save_view_user_settings({ add_totals_row: this$1.add_totals_row });
						this$1.datatable.refresh(this$1.get_data(this$1.data));
					}
				},
				{
					label: __('Print'),
					action: function () {
						this$1.report_data = this$1.data.slice();

						if (this$1.add_totals_row) {
							var total_data = this$1.get_columns_totals(this$1.data);

							total_data['name'] = __('Totals').bold();
							this$1.report_data.push(total_data);
						}

						frappe.ui.get_print_settings(false, function (print_settings) {
							var title =  __(this$1.doctype);
							frappe.render_grid({
								title: title,
								subtitle: this$1.get_filters_html_for_print(),
								print_settings: print_settings,
								columns: this$1.columns,
								data: this$1.report_data
							});
						});
					}
				},
				{
					label: __('Toggle Chart'),
					action: function () { return this$1.toggle_charts(); }
				},
				{
					label: __('Toggle Sidebar'),
					action: function () { return this$1.toggle_side_bar(); }
				},
				{
					label: __('Pick Columns'),
					action: function () {
						var d = new frappe.ui.Dialog({
							title: __('Pick Columns'),
							fields: this$1.get_dialog_fields(),
							primary_action: function (values) {
								// doctype fields
								var fields = values[this$1.doctype].map(function (f) { return [f, this$1.doctype]; });
								delete values[this$1.doctype];

								// child table fields
								var loop = function ( cdt ) {
									fields = fields.concat(values[cdt].map(function (f) { return [f, cdt]; }));
								};

								for (var cdt in values) loop( cdt );

								// always keep name (ID) column
								this$1.fields = [["name", this$1.doctype] ].concat( fields);

								this$1.fields.map(function (f) { return this$1.add_currency_column(f[0], f[1]); });

								this$1.build_fields();
								this$1.setup_columns();

								this$1.datatable.destroy();
								this$1.datatable = null;
								this$1.refresh();

								d.hide();
							}
						});

						d.show();
					}
				}
			];

			if (frappe.model.can_export(this.doctype)) {
				items.push({
					label: __('Export'),
					action: function () {
						var args = this$1.get_args();
						var selected_items = this$1.get_checked_items(true);

						var d = new frappe.ui.Dialog({
							title: __("Export Report: {0}",[__(this$1.doctype)]),
							fields: [
								{
									fieldtype: 'Select',
									label: __('Select File Type'),
									fieldname:'file_format_type',
									options: ['Excel', 'CSV'],
									default: 'Excel'
								},
								{
									fieldtype: 'Check',
									fieldname: 'export_all_rows',
									label: __('Export All {0} rows?', [(this$1.total_count + "").bold()])
								}
							],
							primary_action_label: __('Download'),
							primary_action: function (data) {
								args.cmd = 'frappe.desk.reportview.export_query';
								args.file_format_type = data.file_format_type;

								if(this$1.add_totals_row) {
									args.add_totals_row = 1;
								}

								if(selected_items.length > 0) {
									args.selected_items = selected_items;
								}

								if (!data.export_all_rows) {
									args.start = 0;
									args.page_length = this$1.data.length;
								} else {
									delete args.start;
									delete args.page_length;
								}

								open_url_post(frappe.request.url, args);

								d.hide();
							},
						});

						d.show();
					}
				});
			}

			items.push({
				label: __("Setup Auto Email"),
				action: function () {
					if(this$1.report_name) {
						frappe.set_route('List', 'Auto Email Report', {'report' : this$1.report_name});
					} else {
						frappe.msgprint(__('Please save the report first'));
					}
				}
			});

			// save buttons
			if(frappe.user.is_report_manager()) {
				items = items.concat([
					{ label: __('Save'), action: function () { return this$1.save_report('save'); } },
					{ label: __('Save As'), action: function () { return this$1.save_report('save_as'); } }
				]);
			}

			// user permissions
			if(this.report_name && frappe.model.can_set_user_permissions("Report")) {
				items.push({
					label: __("User Permissions"),
					action: function () {
						var args = {
							doctype: "Report",
							name: this$1.report_name
						};
						frappe.set_route('List', 'User Permission', args);
					}
				});
			}

			// add to desktop
			items.push({
				label: __('Add to Desktop'),
				action: function () {
					frappe.add_to_desktop(
						this$1.report_name || __('{0} Report', [this$1.doctype]),
						this$1.doctype, this$1.report_name
					);
				}
			});

			return items.map(function (i) { return Object.assign(i, { standard: true }); });
		}

	};

	frappe.templates['reportview_footer'] = '<div class="row">  <div class="col-md-6">   {% if has_child_column %}    <div class="checkbox">        <label>            <input type="checkbox" class="show-all-data"       style="margin-top: 2px"       {{ show_all_data ? "checked" : "" }}>       {{ __("Show all data") }}        </label>    </div>   {% endif %}  </div>  {% if can_write %}  <div class="col-md-6 text-right"><p class="text-muted">   {{ __("Tip:  Double click cell to edit") }}</p></div>  {% endif %} </div>';

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.views');
	frappe.provide('frappe.query_reports');

	frappe.standard_pages['query-report'] = function() {
		var wrapper = frappe.container.add_page('query-report');

		frappe.ui.make_app_page({
			parent: wrapper,
			title: __('Query Report'),
			single_column: true,
		});

		frappe.query_report = new frappe.views.QueryReport({
			parent: wrapper,
		});

		$(wrapper).bind('show', function() {
			frappe.query_report.show();
		});
	};

	frappe.views.QueryReport = class QueryReport extends frappe.views.BaseList {
		show() {
			var this$1 = this;

			this.init().then(function () { return this$1.load(); });
		}

		init() {
			var this$1 = this;

			if (this.init_promise) {
				return this.init_promise;
			}

			var tasks = [
				this.setup_defaults,
				this.setup_page,
				this.setup_report_wrapper,
				this.setup_events
			].map(function (fn) { return fn.bind(this$1); });
			this.init_promise = frappe.run_serially(tasks);
			return this.init_promise;
		}

		setup_defaults() {
			var this$1 = this;

			this.route = frappe.get_route();
			this.page_name = frappe.get_route_str();

			// Setup buttons
			this.primary_action = null;
			this.secondary_action = {
				label: __('Refresh'),
				action: function () {
					if(this$1.execution_time > 2) {
						this$1.setup_progress_bar();
					}

					this$1.refresh();
				}
			};

			// throttle refresh for 300ms
			this.refresh = frappe.utils.throttle(this.refresh, 300);

			this.menu_items = [];
		}

		setup_events() {
			var this$1 = this;

			frappe.realtime.on("report_generated", function (data) {
				if(data.report_name) {
					this$1.prepared_report_action = "Rebuild";
					// If generated report and currently active Prepared Report has same fiters
					// then refresh the Prepared Report
					// Otherwise show alert with the link to the Prepared Report
					if(data.name == this$1.prepared_report_doc_name) {
						this$1.refresh();
					} else {
						var alert_message = "Report " + (this$1.report_name) + " generated.\n\t\t\t\t\t\t<a href=\"#query-report/" + (this$1.report_name) + "/?prepared_report_name=" + (data.name) + "\">View</a>";
						frappe.show_alert({message: alert_message, indicator: 'orange'});
					}
				}
			});
		}

		load() {
			if (frappe.get_route().length < 2) {
				this.toggle_nothing_to_show(true);
				return;
			}
			if (this.report_name !== frappe.get_route()[1]) {
				// this.toggle_loading(true);
				// different report
				this.load_report();
			} else {
				// same report
				this.refresh_report();
			}
		}

		load_report() {
			var this$1 = this;

			this.page.clear_inner_toolbar();
			this.route = frappe.get_route();
			this.page_name = frappe.get_route_str();
			this.report_name = this.route[1];
			this.page_title = __(this.report_name);
			this.menu_items = this.get_menu_items();
			this.datatable = null;
			this.prepared_report_action = "New";

			frappe.run_serially([
				function () { return this$1.get_report_doc(); },
				function () { return this$1.get_report_settings(); },
				function () { return this$1.setup_progress_bar(); },
				function () { return this$1.setup_page_head(); },
				function () { return this$1.refresh_report(); },
				function () { return this$1.add_make_chart_button(); }
			]);
		}

		add_make_chart_button(){
			var this$1 = this;

			this.page.add_inner_button(__("Set Chart"), function () {
				this$1.get_possible_chart_options();
			});
		}

		refresh_report() {
			var this$1 = this;

			this.toggle_message(true);

			return frappe.run_serially([
				function () { return this$1.setup_filters(); },
				function () { return this$1.set_route_filters(); },
				function () { return this$1.report_settings.onload && this$1.report_settings.onload(this$1); },
				function () { return this$1.get_user_settings(); },
				function () { return this$1.refresh(); }
			]);
		}

		get_report_doc() {
			var this$1 = this;

			return frappe.model.with_doc('Report', this.report_name)
				.then(function (doc) {
					this$1.report_doc = doc;
				})
				.then(function () { return frappe.model.with_doctype(this$1.report_doc.ref_doctype); });
		}

		get_report_settings() {
			var this$1 = this;

			if (frappe.query_reports[this.report_name]) {
				this.report_settings = frappe.query_reports[this.report_name];
				return this._load_script;
			}

			this._load_script = (new Promise(function (resolve) { return frappe.call({
				method: 'frappe.desk.query_report.get_script',
				args: { report_name: this$1.report_name },
				callback: resolve
			}); })).then(function (r) {
				frappe.dom.eval(r.message.script || '');
				return r;
			}).then(function (r) {
				return frappe.after_ajax(function () {
					this$1.report_settings = frappe.query_reports[this$1.report_name];
					this$1.report_settings.html_format = r.message.html_format;
					this$1.report_settings.execution_time = r.message.execution_time || 0;
				});
			});

			return this._load_script;
		}

		setup_progress_bar() {
			var seconds_elapsed = 0;
			var execution_time = this.report_settings.execution_time < 10
				? 10 : this.report_settings.execution_time;

			this.interval = setInterval(function()  {
				seconds_elapsed += 1;
				frappe.show_progress(__('Preparing Report'), seconds_elapsed, execution_time);
			}, 1000);
		}

		setup_filters() {
			var this$1 = this;

			this.clear_filters();
			var ref = this.report_settings;
			var filters = ref.filters; if ( filters === void 0 ) filters = [];

			this.filters = filters.map(function (df) {
				if (df.fieldtype === 'Break') { return; }

				var f = this$1.page.add_field(df);

				if (df.default) {
					f.set_input(df.default);
				}

				if (df.get_query) { f.get_query = df.get_query; }
				if (df.on_change) { f.on_change = df.on_change; }

				df.onchange = function () {
					if (this$1.previous_filters
						&& (JSON.stringify(this$1.previous_filters) == JSON.stringify(this$1.get_filter_values()))) {
						// filter values have not changed
						return;
					}
					this$1.previous_filters = this$1.get_filter_values();

					// clear previous_filters after 3 seconds, to allow refresh for new data
					setTimeout(function () { return this$1.previous_filters = null; }, 10000);

					if (f.on_change) {
						f.on_change(this$1);
					} else {
						if (this$1.prepared_report) {
							this$1.reset_report_view();
						}
						else if (!this$1._no_refresh) {
							this$1.refresh();
						}
					}
				};

				f = Object.assign(f, df);

				return f;

			}).filter(Boolean);

			if (this.filters.length === 0) {
				// hide page form if no filters
				this.page.hide_form();
			} else {
				this.page.show_form();
			}
		}

		set_filters(filters) {
			this.filters.map(function (f) {
				f.set_input(filters[f.fieldname]);
			});
		}

		set_route_filters() {
			if(frappe.route_options) {
				var fields = Object.keys(frappe.route_options);

				var filters_to_set = this.filters.filter(function (f) { return fields.includes(f.df.fieldname); });

				var promises = filters_to_set.map(function (f) {
					return function () {
						var value = frappe.route_options[f.df.fieldname];
						return f.set_value(value);
					};
				});
				promises.push(function () {
					frappe.route_options = null;
				});

				return frappe.run_serially(promises);
			}
		}

		clear_filters() {
			this.page.clear_fields();
		}

		refresh() {
			var this$1 = this;

			this.toggle_message(true);
			var filters = this.get_filter_values(true);
			var query = frappe.utils.get_query_string(frappe.get_route_str());

			if(query) {
				var obj = frappe.utils.get_query_params(query);
				filters = Object.assign(filters || {}, obj);
			}

			// only one refresh at a time
			if (this.last_ajax) {
				this.last_ajax.abort();
			}

			return new Promise(function (resolve) {
				this$1.last_ajax = frappe.call({
					method: 'frappe.desk.query_report.run',
					type: 'GET',
					args: {
						report_name: this$1.report_name,
						filters: filters,
					},
					callback: resolve,
					always: function () { return this$1.page.btn_secondary.prop('disabled', false); }
				});
			}).then(function (r) {
				var data = r.message;
				this$1.hide_status();
				clearInterval(this$1.interval);

				this$1.execution_time = data.execution_time || 0.1;

				if (data.prepared_report) {
					this$1.prepared_report = true;
					var query_string = frappe.utils.get_query_string(frappe.get_route_str());
					var query_params = frappe.utils.get_query_params(query_string);
					// If query_string contains prepared_report_name then set filters
					// to match the mentioned prepared report doc and disable editing
					if(query_params.prepared_report_name) {
						this$1.prepared_report_action = "Edit";
						var filters_from_report = JSON.parse(data.doc.filters);
						Object.values(this$1.filters).forEach(function(field) {
							if (filters_from_report[field.fieldname]) {
								field.set_input(filters_from_report[field.fieldname]);
							}
							field.input.disabled = true;
						});
					}
					this$1.add_prepared_report_buttons(data.doc);
				}
				this$1.toggle_message(false);

				if (data.result && data.result.length) {
					this$1.prepare_report_data(data);

					var chart_options = this$1.get_chart_options(data);
					this$1.$chart.empty();
					if(chart_options) {
						this$1.render_chart(chart_options);
					}

					this$1.render_datatable();
				} else {
					this$1.toggle_nothing_to_show(true);
				}

				this$1.show_footer_message();
				frappe.hide_progress();
			});
		}

		add_prepared_report_buttons(doc) {
			var this$1 = this;

			if(doc){
				this.page.add_inner_button(__("Download Report"), function (){
					window.open(
						frappe.urllib.get_full_url(
							"/api/method/frappe.core.doctype.prepared_report.prepared_report.download_attachment?"
							+"dn="+encodeURIComponent(doc.name)));
				});

				var part1 = __('This report was generated {0}.', [frappe.datetime.comment_when(doc.report_end_time)]);
				var part2 = __('To get the updated report, click on {0}.', [__('Rebuild')]);
				var part3 = __('See all past reports.');

				this.show_status(("\n\t\t\t\t<span class=\"indicator orange\">\n\t\t\t\t\t" + part1 + "\n\t\t\t\t\t" + part2 + "\n\t\t\t\t\t<a href=\"#List/Prepared%20Report?report_name=" + (this.report_name) + "\">" + part3 + "</a>\n\t\t\t\t</span>\n\t\t\t"));
			}
			// Three cases
			// 1. First time with given filters, no data.
			// 2. Showing data from specific report
			// 3. Showing data from an old report without specific report name
			if(this.prepared_report_action == "New") {
				this.page.set_primary_action(
					__("Generate New Report"),
					function () {
						this$1.generate_background_report();
					}
				);
			} else if(this.prepared_report_action == "Edit") {
				this.page.set_primary_action(
					__("Edit"),
					function () {
						frappe.set_route(frappe.get_route());
					}
				);
			} else if(this.prepared_report_action == "Rebuild"){
				this.page.set_primary_action(
					__("Rebuild"),
					this.generate_background_report.bind(this)
				);
			}
		}

		generate_background_report() {
			var this$1 = this;

			var mandatory = this.filters.filter(function (f) { return f.df.reqd; });
			var missing_mandatory = mandatory.filter(function (f) { return !f.get_value(); });
			if (!missing_mandatory.length){
				var filters = this.get_filter_values(true);
				return new Promise(function (resolve) { return frappe.call({
					method: 'frappe.desk.query_report.background_enqueue_run',
					type: 'GET',
					args: {
						report_name: this$1.report_name,
						filters: filters
					},
					callback: resolve
				}); }).then(function (r) {
					var data = r.message;
					// Rememeber the name of Prepared Report doc
					this$1.prepared_report_doc_name = data.name;
					var alert_message = "Report initiated. You can track its status\n\t\t\t\t\t<a class='text-info' href='#Form/Prepared Report/" + (data.name) + "'>here</a>";
					frappe.show_alert({message: alert_message, indicator: 'orange'});
					this$1.toggle_nothing_to_show(true);
				});
			}
		}

		prepare_report_data(data) {
			this.raw_data = data;
			this.columns = this.prepare_columns(data.columns);
			this.data = this.prepare_data(data.result);

			this.tree_report = this.data.some(function (d) { return 'indent' in d; });
		}

		render_datatable() {
			var data = this.data;
			if (this.raw_data.add_total_row) {
				data = data.slice();
				data.splice(-1, 1);
			}

			if (this.datatable) {
				this.datatable.options.treeView = this.tree_report;
				this.datatable.refresh(data, this.columns);
			} else {
				var datatable_options = {
					columns: this.columns,
					data: data,
					inlineFilters: true,
					treeView: this.tree_report,
					layout: 'fixed',
					cellHeight: 33,
					showTotalRow: this.raw_data.add_total_row,
					hooks: {
						totalAccumulator: frappe.utils.report_total_accumulator
					}
				};

				if (this.report_settings.get_datatable_options) {
					datatable_options = this.report_settings.get_datatable_options(datatable_options);
				}
				this.datatable = new DataTable(this.$report[0], datatable_options);
			}

			if (this.report_settings.after_datatable_render) {
				this.report_settings.after_datatable_render(this.datatable);
			}
		}

		get_chart_options(data) {
			var options = this.report_settings.get_chart_data
				? this.report_settings.get_chart_data(data.columns, data.result)
				: data.chart
					? data.chart
					: undefined;

			if (!(options && options.data && options.data.labels && options.data.labels.length > 0)) { return; }

			return options;
		}

		render_chart(options, height) {
			if ( height === void 0 ) height=200;

			Object.assign(options, {
				height: height
			});

			this.$chart.empty();
			this.chart = new Chart(this.$chart[0], options);
			this.$chart.show();
		}

		get_possible_chart_options() {
			var this$1 = this;

			var columns = this.raw_data.columns;
			var rows =  this.raw_data.result;
			var first_row = rows[0];
			var has_total_row = this.raw_data.add_total_row;

			var indices = first_row.reduce(function (accumulator, current_value, current_index) {
				if(!isNaN(Number(current_value))) {
					accumulator.push(current_index);
				}
				return accumulator;
			}, []);

			function get_column_values(column_name) {
				var column_index = columns.indexOf(column_name);
				return rows.map(function (row) { return row[column_index]; });
			}

			function get_chart_options(ref) {
				var y_field = ref.y_field;
				var x_field = ref.x_field;
				var chart_type = ref.chart_type;
				var color = ref.color;

				var type = chart_type.toLowerCase();
				var colors = color ? [color] : undefined;

				var labels = get_column_values(x_field)
					.filter(Boolean)
					.map(function (d) { return d.trim(); })
					.filter(Boolean);

				var dataset_values = get_column_values(y_field).map(function (d) { return Number(d); });

				if(has_total_row) {
					labels = labels.slice(0, -1);
					dataset_values = dataset_values.slice(0, -1);
				}

				return {
					data: {
						labels: labels,
						datasets: [
							{ values: dataset_values }
						]
					},
					type: type,
					colors: colors
				};
			}

			function preview_chart() {
				var wrapper = $(dialog.fields_dict["chart_preview"].wrapper);
				var values = dialog.get_values(true);
				var options = get_chart_options(values);

				Object.assign(options, {
					height: 150
				});

				wrapper.empty();
				new Chart(wrapper[0], options);
				wrapper.find('.chart-container .title, .chart-container .sub-title').hide();
				wrapper.show();
			}

			var numeric_fields = columns.filter(function (col, i) { return indices.includes(i); });
			var non_numeric_fields = columns.filter(function (col, i) { return !indices.includes(i); });

			var dialog = new frappe.ui.Dialog({
				title: __('Make Chart'),
				fields: [
					{
						fieldname: 'y_field',
						label: 'Y Field',
						fieldtype: 'Select',
						options: numeric_fields,
						default: numeric_fields[0],
						onchange: preview_chart
					},
					{
						fieldname: 'x_field',
						label: 'X Field',
						fieldtype: 'Select',
						options: non_numeric_fields,
						default: non_numeric_fields[0],
						onchange: preview_chart
					},
					{
						fieldname: 'cb_1',
						fieldtype: 'Column Break'
					},
					{
						fieldname: 'chart_type',
						label: 'Type of Chart',
						fieldtype: 'Select',
						options: ['Bar', 'Line', 'Percentage', 'Pie'],
						default: 'Bar',
						onchange: preview_chart
					},
					{
						fieldname: 'color',
						label: 'Color',
						fieldtype: 'Color',
						depends_on: function (doc) { return ['Bar', 'Line'].includes(doc.chart_type); },
						onchange: preview_chart,
					},
					{
						fieldname: 'sb_1',
						fieldtype: 'Section Break',
						label: 'Chart Preview'
					},
					{
						fieldname: 'chart_preview',
						label: 'Chart Preview',
						fieldtype: 'HTML',
					}
				],
				primary_action_label: __('Make'),
				primary_action: function (values) {
					var options = get_chart_options(values);

					options.title = __(((this$1.report_name) + ": " + (values.y_field) + " vs " + (values.x_field)));

					this$1.render_chart(options);

					dialog.hide();
				}
			});

			dialog.show();

			// load preview after dialog animation
			setTimeout(preview_chart, 500);
		}

		get_user_settings() {
			var this$1 = this;

			return frappe.model.user_settings.get(this.report_name)
				.then(function (user_settings) {
					this$1.user_settings = user_settings;
				});
		}

		prepare_columns(columns) {
			var this$1 = this;

			return columns.map(function (column) {
				var assign;

				if (typeof column === 'string') {
					if (column.includes(':')) {
						var ref = column.split(':');
						var label = ref[0];
						var fieldtype = ref[1];
						var width = ref[2];
						var options;

						if (fieldtype.includes('/')) {
							(assign = fieldtype.split('/'), fieldtype = assign[0], options = assign[1]);
						}

						column = {
							label: label,
							fieldname: label,
							fieldtype: fieldtype,
							width: width,
							options: options
						};
					} else {
						column = {
							label: column,
							fieldname: column,
							fieldtype: 'Data'
						};
					}
				}

				var format_cell = function (value, row, column, data) {
					return frappe.format(value == null ? '' : value, column,
						{for_print: false, always_show_decimals: true}, data);
				};

				var compareFn = null;
				if (column.fieldtype === 'Date') {
					compareFn = function (cell, keyword) {
						if (!cell.content) { return null; }
						if (keyword.length !== 'YYYY-MM-DD'.length) { return null; }

						var keywordValue = frappe.datetime.user_to_obj(keyword);
						var cellValue = frappe.datetime.str_to_obj(cell.content);
						return [+cellValue, +keywordValue];
					};
				}

				return Object.assign(column, {
					id: column.fieldname,
					name: column.label,
					width: parseInt(column.width) || null,
					editable: false,
					compareValue: compareFn,
					format: function (value, row, column, data) {
						if (this$1.report_settings.formatter) {
							return this$1.report_settings.formatter(value, row, column, data, format_cell);
						}
						return format_cell(value, row, column, data);
					}
				});
			});
		}

		prepare_data(data) {
			var this$1 = this;

			return data.map(function (row) {
				var row_obj = {};
				if (Array.isArray(row)) {
					this$1.columns.forEach(function (column, i) {
						row_obj[column.id] = row[i];
					});

					return row_obj;
				}
				return row;
			});
		}

		get_visible_columns() {
			var this$1 = this;

			var visible_column_ids = this.datatable.datamanager.getColumns(true).map(function (col) { return col.id; });

			return visible_column_ids
				.map(function (id) { return this$1.columns.find(function (col) { return col.id === id; }); })
				.filter(Boolean);
		}

		get_filter_values(raise) {
			var mandatory = this.filters.filter(function (f) { return f.df.reqd; });
			var missing_mandatory = mandatory.filter(function (f) { return !f.get_value(); });
			if (raise && missing_mandatory.length > 0) {
				var message = __('Please set filters');
				this.toggle_message(raise, message);
				throw "Filter missing";
			}

			var filters = this.filters
				.filter(function (f) { return f.get_value(); })
				.map(function (f) {
					var obj;

					var v = f.get_value();
					// hidden fields dont have $input
					if(f.df.hidden) { v = f.value; }
					if(v === '%') { v = null; }
					return ( obj = {}, obj[f.df.fieldname] = v, obj );
				})
				.reduce(function (acc, f) {
					Object.assign(acc, f);
					return acc;
				}, {});
			return filters;
		}

		get_filter(fieldname) {
			var field = (this.filters || []).find(function (f) { return f.df.fieldname === fieldname; });
			if (!field) {
				console.warn(("[Query Report] Invalid filter: " + fieldname));
			}
			return field;
		}

		get_filter_value(fieldname) {
			var field = this.get_filter(fieldname);
			return field ? field.get_value() : null;
		}

		set_filter_value(fieldname, value) {
			var this$1 = this;

			var field_value_map = {};
			if (typeof fieldname === 'string') {
				field_value_map[fieldname] = value;
			} else {
				field_value_map = fieldname;
			}

			this._no_refresh = true;
			Object.keys(field_value_map)
				.forEach(function (fieldname, i, arr) {
					var value = field_value_map[fieldname];

					if (i === arr.length - 1) {
						this$1._no_refresh = false;
					}

					this$1.get_filter(fieldname).set_value(value);
				});
		}

		set_breadcrumbs() {
			if (!this.report_doc || !this.report_doc.ref_doctype) { return; }
			var ref_doctype = frappe.get_meta(this.report_doc.ref_doctype);
			frappe.breadcrumbs.add(ref_doctype.module);
		}

		print_report(print_settings) {
			var custom_format = this.report_settings.html_format || null;
			var filters_html = this.get_filters_html_for_print();
			var landscape = print_settings.orientation == 'Landscape';

			frappe.render_grid({
				template: custom_format,
				title: __(this.report_name),
				subtitle: filters_html,
				print_settings: print_settings,
				landscape: landscape,
				filters: this.get_filter_values(),
				data: custom_format ? this.data : this.get_data_for_print(),
				columns: custom_format ? this.columns : this.get_columns_for_print(),
				report: this
			});
		}

		pdf_report(print_settings) {
			var base_url = frappe.urllib.get_base_url();
			var print_css = frappe.boot.print_css;
			var landscape = print_settings.orientation == 'Landscape';

			var custom_format = this.report_settings.html_format || null;
			var columns = custom_format ? this.columns : this.get_columns_for_print();
			var data = custom_format ? this.data : this.get_data_for_print();
			var applied_filters = this.get_filter_values();

			var filters_html = this.get_filters_html_for_print();
			var content = frappe.render_template(custom_format || 'print_grid', {
				title: __(this.report_name),
				subtitle: filters_html,
				filters: applied_filters,
				data: data,
				columns: columns,
				report: this
			});

			// Render Report in HTML
			var html = frappe.render_template('print_template', {
				title: __(this.report_name),
				content: content,
				base_url: base_url,
				print_css: print_css,
				print_settings: print_settings,
				landscape: landscape,
				columns: columns
			});

			frappe.render_pdf(html, print_settings);
		}

		get_filters_html_for_print() {
			var applied_filters = this.get_filter_values();
			return Object.keys(applied_filters)
				.map(function (fieldname) {
					var label = frappe.query_report.get_filter(fieldname).df.label;
					var value = applied_filters[fieldname];
					return ("<h6>" + (__(label)) + ": " + value + "</h6>");
				})
				.join('');
		}

		export_report() {
			var this$1 = this;

			if (this.export_dialog) {
				this.export_dialog.clear();
				this.export_dialog.show();
				return;
			}

			this.export_dialog = frappe.prompt([
				{
					label: __('Select File Format'),
					fieldname: 'file_format',
					fieldtype: 'Select',
					options: ['Excel', 'CSV'],
					default: 'Excel',
					reqd: 1,
					onchange: function () {
						this$1.export_dialog.set_df_property('with_indentation',
							'hidden', this$1.export_dialog.get_value('file_format') !== 'CSV');
					}
				},
				{
					label: __('With Group Indentation'),
					fieldname: 'with_indentation',
					fieldtype: 'Check',
					hidden: 1
				}
			], function (ref) {
				var file_format = ref.file_format;
				var with_indentation = ref.with_indentation;

				if (file_format === 'CSV') {
					var column_row = this$1.columns.map(function (col) { return col.label; });
					var data = this$1.get_data_for_csv(with_indentation);
					var out = [column_row].concat(data);

					frappe.tools.downloadify(out, null, this$1.report_name);
				} else {
					var filters = this$1.get_filter_values(true);
					if (frappe.urllib.get_dict("prepared_report_name")) {
						filters = Object.assign(frappe.urllib.get_dict("prepared_report_name"), filters);
					}

					var visible_idx = this$1.datatable.datamanager.getFilteredRowIndices();
					if (visible_idx.length + 1 === this$1.data.length) {
						visible_idx.push(visible_idx.length);
					}

					var args = {
						cmd: 'frappe.desk.query_report.export_query',
						report_name: this$1.report_name,
						file_format_type: file_format,
						filters: filters,
						visible_idx: visible_idx,
					};

					open_url_post(frappe.request.url, args);
				}
			}, __('Export Report: '+ this.report_name), __('Download'));
		}

		get_data_for_csv(with_indentation) {
			var this$1 = this;
			if ( with_indentation === void 0 ) with_indentation = false;


			var indices = this.datatable.datamanager.getFilteredRowIndices();
			var rows = indices.map(function (i) { return this$1.datatable.datamanager.getRow(i); });
			return rows.map(function (row) {
				var standard_column_count = this$1.datatable.datamanager.getStandardColumnCount();
				return row
					.slice(standard_column_count)
					.map(function (cell, i) {
					if (with_indentation && i === 0) {
						return '   '.repeat(row.meta.indent) + cell.content;
					}
					return cell.content;
				});
			});
		}

		get_data_for_print() {
			var this$1 = this;

			var indices = this.datatable.datamanager.getFilteredRowIndices();
			return indices.map(function (i) { return this$1.data[i]; });
		}

		get_columns_for_print() {
			return this.get_visible_columns();
		}

		get_menu_items() {
			var this$1 = this;

			return [
				{
					label: __('Refresh'),
					action: function () { return this$1.refresh(); },
					class: 'visible-xs'
				},
				{
					label: __('Edit'),
					action: function () { return frappe.set_route('Form', 'Report', this$1.report_name); },
					condition: function () { return frappe.user.is_report_manager(); },
					standard: true
				},
				{
					label: __('Print'),
					action: function () {
						frappe.ui.get_print_settings(
							false,
							function (print_settings) { return this$1.print_report(print_settings); },
							this$1.report_doc.letter_head
						);
					},
					condition: function () { return frappe.model.can_print(this$1.report_doc.ref_doctype); },
					standard: true
				},
				{
					label: __('PDF'),
					action: function () {
						frappe.ui.get_print_settings(
							false,
							function (print_settings) { return this$1.pdf_report(print_settings); },
							this$1.report_doc.letter_head
						);
					},
					condition: function () { return frappe.model.can_print(this$1.report_doc.ref_doctype); },
					standard: true
				},
				{
					label: __('Export'),
					action: function () { return this$1.export_report(); },
					standard: true
				},
				{
					label: __('Setup Auto Email'),
					action: function () { return frappe.set_route('List', 'Auto Email Report', {'report' : this$1.report_name}); },
					standard: true
				},
				{
					label: __('User Permissions'),
					action: function () { return frappe.set_route('List', 'User Permission', {
						doctype: 'Report',
						name: this$1.report_name
					}); },
					condition: function () { return frappe.model.can_set_user_permissions('Report'); },
					standard: true
				},
				{
					label: __('Add to Desktop'),
					action: function () { return frappe.add_to_desktop(this$1.report_name, null, this$1.report_name); },
					standard: true
				} ];
		}

		setup_report_wrapper() {
			if (this.$report) { return; }

			var page_form = this.page.main.find('.page-form');
			this.$status = $("<div class=\"form-message text-muted small\"></div>")
				.hide().insertAfter(page_form);

			this.$chart = $('<div class="chart-wrapper">').hide().appendTo(this.page.main);
			this.$report = $('<div class="report-wrapper">').appendTo(this.page.main);
			this.$message = $(this.message_div('')).hide().appendTo(this.page.main);
		}

		show_status(status_message) {
			this.$status.html(status_message).show();
		}

		hide_status() {
			this.$status.hide();
		}

		show_footer_message() {
			var message = __('For comparison, use >5, <10 or =324. For ranges, use 5:10 (for values between 5 & 10).');
			var execution_time_msg = __('Exection Time: {0} sec', [this.execution_time || 0.1]);

			this.page.footer.removeClass('hide').addClass('text-muted col-md-12')
				.html(("<span class=\"text-left col-md-6\">" + message + "</span><span class=\"text-right col-md-6\">" + execution_time_msg + "</span>"));
		}

		message_div(message) {
			return ("<div class='flex justify-center align-center text-muted' style='height: 50vh;'>\n\t\t\t<div>" + message + "</div>\n\t\t</div>");
		}

		reset_report_view() {
			this.hide_status();
			this.toggle_nothing_to_show(true);
			this.refresh();
		}

		toggle_loading(flag) {
			this.toggle_message(flag, __('Loading') + '...');
		}


		toggle_nothing_to_show(flag) {
			var message = this.prepared_report
				? __('This is a background report. Please set the appropriate filters and then generate a new one.')
				: __('Nothing to show');

			this.toggle_message(flag, message);

			if (flag && this.prepared_report) {
				this.prepared_report_action = "New";
				this.add_prepared_report_buttons();
			}
		}

		toggle_message(flag, message) {
			if (flag) {
				this.$message.find('div').html(message);
				this.$message.show();
			} else {
				this.$message.hide();
			}
			this.$report.toggle(!flag);
			this.$chart.toggle(!flag);
		}
		// backward compatibility
		get get_values() {
			return this.get_filter_values;
		}
	};

	Object.defineProperty(frappe, 'query_report_filters_by_name', {
		get: function get() {
			console.warn('[Query Report] frappe.query_report_filters_by_name is deprecated. Please use the new api: frappe.query_report.get_filter_value(fieldname) and frappe.query_report.set_filter_value(fieldname, value)');
			return null;
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	frappe.provide("frappe.report_dump");

	$.extend(frappe.report_dump, {
		data: {},
		last_modified: {},
		with_data: function(doctypes, callback) {
			var pre_loaded = Object.keys(frappe.report_dump.last_modified);
			return frappe.call({
				method: "frappe.desk.report_dump.get_data",
				type: "GET",
				args: {
					doctypes: doctypes,
					last_modified: frappe.report_dump.last_modified
				},
				freeze: true,
				callback: function(r) {
					// creating map of data from a list
					$.each(r.message, function(doctype, doctype_data) {
						frappe.report_dump.set_data(doctype, doctype_data);
					});

					// reverse map names
					$.each(r.message, function(doctype, doctype_data) {
						// only if not pre-loaded
						if(!in_list(pre_loaded, doctype)) {
							if(doctype_data.links) {
								$.each(frappe.report_dump.data[doctype], function(row_idx, row) {
									$.each(doctype_data.links, function(link_key, link) {
										if(frappe.report_dump.data[link[0]][row[link_key]]) {
											row[link_key] = frappe.report_dump.data[link[0]][row[link_key]][link[1]];
										} else {
											row[link_key] = null;
										}
									});
								});
							}
						}
					});

					callback();
				}
			});
		},
		set_data: function(doctype, doctype_data) {
			var data = [];
			var replace_dict = {};
			var make_row = function(d) {
				var row = {};
				$.each(doctype_data.columns, function(idx, col) {
					row[col] = d[idx];
				});
				row.id = row.name;
				row.doctype = doctype;
				return row;
			};
			if(frappe.report_dump.last_modified[doctype]) {
				// partial loading, make a name dict
				$.each(doctype_data.data, function(i, d) {
					var row = make_row(d);
					replace_dict[row.name] = row;
				});

				// replace old data
				$.each(frappe.report_dump.data[doctype], function(i, d) {
					if(replace_dict[d.name]) {
						data.push(replace_dict[d.name]);
						delete replace_dict[d.name];
					} else if(doctype_data.modified_names.indexOf(d.name)!==-1) ; else {
						data.push(d);
					}
				});

				// add new records
				$.each(replace_dict, function(name, d) {
					data.push(d);
				});
			} else {

				// first loading
				$.each(doctype_data.data, function(i, d) {
					data.push(make_row(d));
				});
			}
			frappe.report_dump.last_modified[doctype] = doctype_data.last_modified;
			frappe.report_dump.data[doctype] = data;
		}
	});

	frappe.provide("frappe.views");
	frappe.views.GridReport = Class.extend({
		init: function(opts) {
			this.filter_inputs = {};
			this.preset_checks = [];
			this.tree_grid = {show: false};
			$.extend(this, opts);

			this.wrapper = $('<div class="grid-report"></div>').appendTo(this.page.main);
			this.page.main.find(".page").css({"padding-top": "0px"});

			if(this.filters) {
				this.make_filters();
			}
			this.make_waiting();

			this.get_data_and_refresh();
		},
		bind_show: function() {
			// bind show event to reset cur_report_grid
			// and refresh filters from url
			// this must be called after init
			// because "frappe.container.page" will only be set
			// once "load" event is over.

			var me = this;
			$(this.page).bind('show', function() {
				// reapply filters on show
				frappe.cur_grid_report = me;
				me.get_data_and_refresh();
			});

		},
		get_data_and_refresh: function() {
			var me = this;
			this.get_data(function() {
				me.apply_filters_from_route();
				me.refresh();
			});
		},
		get_data: function(callback) {
			var me = this;

			frappe.report_dump.with_data(this.doctypes, function() {
				if(!me.setup_filters_done) {
					me.setup_filters();
					me.setup_filters_done = true;
				}
				callback();
			});
		},
		setup_filters: function() {
			var me = this;

			$.each(me.filter_inputs, function(i, v) {
				var opts = v.get(0).opts;
				if(opts.fieldtype == "Select" && in_list(me.doctypes, opts.link)) {
					$(v).add_options(frappe.report_dump.data[opts.link].map(function (d) { return d.name; }));
				} else if(opts.fieldtype == "Link" && in_list(me.doctypes, opts.link)) {
					opts.list = frappe.report_dump.data[opts.link].map(function (d) { return d.name; });
					me.set_autocomplete(v, opts.list);
				}
			});

			// refresh
			this.page.set_primary_action(__("Refresh"), function() {
				me.get_data(function() {
					me.refresh();
				});
			});

			// reset filters button
			if (this.filter_inputs) {
				this.page.add_menu_item(__("Reset Filters"), function() {
					me.init_filter_values();
					me.refresh();
				}, true);
			}

			this.page.add_menu_item(__("Print"), function() {
				frappe.ui.get_print_settings(false, function(print_settings) {
					frappe.render_grid({grid: me.grid, title: me.page.title, print_settings: print_settings, report: me});
				});

			}, true);

			// range
			this.filter_inputs.range && this.filter_inputs.range.on("change", function() {
				me.refresh();
			});
		},
		set_filter: function(key, value) {
			var filters = this.filter_inputs[key];
			if(filters) {
				var opts = filters.get(0).opts;
				if(opts.fieldtype === "Check") {
					filters.prop("checked", cint(value) ? true : false);
				} if(opts.fieldtype=="Date") {
					filters.val(frappe.datetime.str_to_user(value));
				} else {
					filters.val(value);
				}
			} else {
				frappe.msgprint(__("Invalid Filter: {0}", [key]));
			}
		},
		set_autocomplete: function($filter, list) {
			var me = this;
			new Awesomplete($filter.get(0), {
				list: list
			});
			$filter.on("awesomplete-select", function(e) {
				var value = e.originalEvent.text.value;
				$filter.val(value);
				me.refresh();
			});
		},
		init_filter_values: function() {
			$.each(this.filter_inputs, function(key, filter) {
				var opts = filter.get(0).opts;
				if(frappe.sys_defaults[key]) {
					filter.val(frappe.sys_defaults[key]);
				} else if(opts.fieldtype=='Select') {
					filter.get(0).selectedIndex = 0;
				} else if(opts.fieldtype=='Data') {
					filter.val("");
				} else if(opts.fieldtype=="Link") {
					filter.val("");
				}
			});

			this.set_default_values();
		},

		set_default_values: function() {
			var values = {
				from_date: frappe.datetime.str_to_user(frappe.sys_defaults.year_start_date),
				to_date: frappe.datetime.str_to_user(frappe.sys_defaults.year_end_date)
			};

			var me = this;
			$.each(values, function(i, v) {
				if(me.filter_inputs[i] && !me.filter_inputs[i].val())
					{ me.filter_inputs[i].val(v); }
			});
		},

		make_filters: function() {
			var me = this;
			$.each(this.filters, function(i, v) {
				v.fieldname = v.fieldname || v.label.replace(/ /g, '_').toLowerCase();
				var input = null;
				if(v.fieldtype=='Select') {
					input = me.page.add_select(v.label, v.options || [v.default_value]);
				} else if(v.fieldtype=="Link") {
					input = me.page.add_data(v.label);
					new Awesomplete(input.get(0), {
						list: v.list || []
					});
				} else if(v.fieldtype==='Button' && v.label===__("Refresh")) {
					input = me.page.set_primary_action(v.label, null, v.icon);
				} else if(v.fieldtype==='Button') {
					input = me.page.add_menu_item(v.label, null, true);
				} else if(v.fieldtype==='Date') {
					input = me.page.add_date(v.label);
				} else if(v.fieldtype==='Label') {
					input = me.page.add_label(v.label);
				} else if(v.fieldtype==='Data') {
					input = me.page.add_data(v.label);
				} else if(v.fieldtype==='Check') {
					input = me.page.add_check(v.label);
				}

				if(input) {
					input && (input.get(0).opts = v);
					if(v.cssClass) {
						input.addClass(v.cssClass);
					}
					input.keypress(function(e) {
						if(e.which==13) {
							me.refresh();
						}
					});
				}
				me.filter_inputs[v.fieldname] = input;
			});
		},
		make_waiting: function() {
			this.waiting = frappe.messages.waiting(this.wrapper, __("Loading Report")+"...");
		},
		load_filter_values: function() {
			var me = this;
			$.each(this.filter_inputs, function(i, f) {
				var opts = f.get(0).opts;
				if(opts.fieldtype=='Check') {
					me[opts.fieldname] = f.prop('checked') ? 1 : 0;
				} else if(opts.fieldtype!='Button') {
					me[opts.fieldname] = f.val();
					if(opts.fieldtype=="Date") {
						me[opts.fieldname] = frappe.datetime.user_to_str(me[opts.fieldname]);
					} else if (opts.fieldtype == "Select") {
						me[opts.fieldname+'_default'] = opts.default_value;
					}
				}
			});

			if(this.filter_inputs.from_date && this.filter_inputs.to_date && (this.to_date < this.from_date)) {
				frappe.msgprint(__("From Date must be before To Date"));
				return;
			}

		},

		make_name_map: function(data, key) {
			var map = {};
			key = key || "name";
			$.each(data, function(i, v) {
				map[v[key]] = v;
			});
			return map;
		},

		reset_item_values: function(item) {
			var me = this;
			$.each(this.columns, function(i, col) {
				if (col.formatter==me.currency_formatter) {
					item[col.id] = 0.0;
				}
			});
		},

		round_item_values: function(item) {
			var me = this;
			$.each(this.columns, function(i, col) {
				if (col.formatter==me.currency_formatter) {
					item[col.id] = flt(item[col.id], frappe.defaults.get_default("float_precision") || 3);
				}
			});
		},

		round_off_data: function() {
			var me = this;
			$.each(this.data, function(i, d) {
				me.round_item_values(d);
			});
		},

		refresh: function() {
			this.waiting.toggle(false);
			if(!this.grid_wrapper)
				{ this.make(); }
			// this.show_zero = $('.show-zero input:checked').length;
			this.load_filter_values();
			this.setup_columns();
			this.setup_dataview_columns();
			this.apply_link_formatters();
			this.prepare_data();
			this.round_off_data();
			this.prepare_data_view();
			// chart might need prepared data
			frappe.show_alert("Updated", 2);
			this.render();
			this.setup_chart && this.setup_chart();
		},
		setup_dataview_columns: function() {
			this.columns = this.columns.filter(function (col) { return !col.hidden; });
			this.datatable_columns = this.columns.map(function (column) {
				return Object.assign(column, {
					format: function (value, row, column, data) {
						return column.formatter ?
							column.formatter(row, {}, value, column, data) :
							value || '';
					}
				});
			});
		},
		make: function() {
			var this$1 = this;

			// chart wrapper
			this.chart_area = $('<div class="chart" style="padding-bottom: 1px"></div>').appendTo(this.wrapper);

			this.page.add_menu_item(__("Export"), function () { return this$1.export(); }, true);

			// grid wrapper
			this.grid_wrapper = $("<div style='height: 500px;'>")
				.appendTo(this.wrapper);
			this.id = frappe.dom.set_unique_id(this.grid_wrapper.get(0));

			this.bind_show();

			frappe.cur_grid_report = this;
			$(this.wrapper).trigger('make');

		},
		apply_filters_from_route: function() {
			var me = this;
			if(frappe.route_options) {
				$.each(frappe.route_options, function(key, value) {
					me.set_filter(key, value);
				});
				frappe.route_options = null;
			} else {
				this.init_filter_values();
			}
			this.set_default_values();

			$(this.wrapper).trigger('apply_filters_from_route');
		},
		options: {
			editable: false,
			enableColumnReorder: false
		},
		render: function() {
			var this$1 = this;

			this.datatable = new DataTable('#' + this.id, {
				columns: this.datatable_columns,
				data: this.data,
				layout: 'fixed',
				inlineFilters: true,
				treeView: true,
				checkboxColumn: true,
				checkedRowStatus: false,
				events: {
					onCheckRow: function (row) {
						var rowIndex = row.meta.rowIndex;
						var checked = this$1.datatable.rowmanager.checkMap[rowIndex];
						var data = this$1.datatable.datamanager.getData(rowIndex);
						data.checked = Boolean(checked);

						this$1.setup_chart && this$1.setup_chart();
					}
				},
				hooks: {
					totalAccumulator: frappe.utils.report_total_accumulator
				}
			});

			this.data.forEach(function (d, i) {
				if (d.checked) {
					this$1.datatable.rowmanager.checkRow(i, true);
				}
			});
		},
		prepare_data_view: function() {
		},
		export: function() {
			frappe.tools.downloadify(frappe.slickgrid_tools.get_view_data(this.columns, this.dataView),
				["Report Manager", "System Manager"], this.title);
			return false;
		},
		apply_filters: function(item) {
			var this$1 = this;

			// generic filter: apply filter functiions
			// from all filter_inputs
			var filters = this.filter_inputs;
			if(item._show) { return true; }

			for (var i in filters) {
				if(!this$1.apply_filter(item, i)) {
					return false;
				}
			}

			return true;
		},
		apply_filter: function(item, fieldname) {
			var filter = this.filter_inputs[fieldname].get(0);
			if(filter.opts.filter) {
				if(!filter.opts.filter(this[filter.opts.fieldname], item, filter.opts, this)) {
					return false;
				}
			}
			return true;
		},
		apply_zero_filter: function(val, item, opts, me) {
			// show only non-zero values
			if(!me.show_zero) {
				for(var i=0, j=me.columns.length; i<j; i++) {
					var col = me.columns[i];
					if(col.formatter==me.currency_formatter && !col.hidden) {
						if(flt(item[col.field]) > 0.001 ||  flt(item[col.field]) < -0.001) {
							return true;
						}
					}
				}
				return false;
			}
			return true;
		},
		show_zero_check: function() {
			var me = this;
			this.wrapper.bind('make', function() {
				me.wrapper.find('.show-zero').toggle(true).find('input').click(function(){
					me.refresh();
				});
			});
		},
		is_default: function(fieldname) {
			return this[fieldname]==this[fieldname + "_default"];
		},
		date_formatter: function(row, cell, value) {
			return frappe.datetime.str_to_user(value);
		},
		currency_formatter: function(row, cell, value, columnDef, dataContext) {
			if (isNaN(value)) { value = ''; }
			return repl('<div style="text-align: right; %(_style)s">%(value)s</div>', {
				_style: dataContext._style || "",
				value: ((value==null || value==="") ? "" : format_number(value))
			});
		},
		text_formatter: function(row, cell, value, columnDef, dataContext) {
			return repl('<span style="%(_style)s" title="%(esc_value)s">%(value)s</span>', {
				_style: dataContext._style || "",
				esc_value: cstr(value).replace(/"/g, '\\"'),
				value: cstr(value)
			});
		},
		check_formatter: function(row, cell, value, columnDef, dataContext) {
			return repl('<input type="checkbox" data-id="%(id)s" \
			class="chart-check" %(checked)s>', {
					"id": dataContext.id,
					"checked": dataContext.checked ? 'checked="checked"' : ""
				});
		},
		apply_link_formatters: function() {
			$.each(this.columns, function(i, col) {
				if(col.link_formatter) {
					col.formatter = function(row, cell, value, columnDef, dataContext, for_print) {
						// added link and open button to links
						// link_formatter must have
						// filter_input, open_btn (true / false), doctype (will be eval'd)
						if(!value) { return ""; }

						if(for_print) {
							return value;
						}

						var me = frappe.cur_grid_report;

						if(dataContext._show) {
							return repl('<span style="%(_style)s">%(value)s</span>', {
								_style: dataContext._style || "",
								value: value
							});
						}

						// make link to add a filter
						var html;
						var link_formatter = me.dataview_columns[cell].link_formatter;
						if (link_formatter.filter_input) {
							html = repl('<a href="#" \
							onclick="frappe.cur_grid_report.set_filter(\'%(col_name)s\', \'%(value)s\'); \
								frappe.cur_grid_report.refresh(); return false;">\
							%(value)s</a>', {
									value: value,
									col_name: link_formatter.filter_input,
									page_name: frappe.container.page.page_name
								});
						} else {
							html = value;
						}

						// make icon to open form
						if(link_formatter.open_btn) {
							var doctype = link_formatter.doctype
								? eval(link_formatter.doctype)
								: dataContext.doctype;
							html += me.get_link_open_icon(doctype, value);
						}
						return html;
					};
				}
			});
		},
		get_link_open_icon: function(doctype, name) {
			return repl(' <a href="#Form/%(doctype)s/%(name)s">\
			<i class="fa fa-share" style="cursor: pointer;"></i></a>', {
					doctype: doctype,
					name: encodeURIComponent(name)
				});
		},
		make_date_range_columns: function() {
			this.columns = [];

			var me = this;
			var range = this.filter_inputs.range.val();
			this.from_date = frappe.datetime.user_to_str(this.filter_inputs.from_date.val());
			this.to_date = frappe.datetime.user_to_str(this.filter_inputs.to_date.val());
			var date_diff = frappe.datetime.get_diff(this.to_date, this.from_date);

			me.column_map = {};
			me.last_date = null;

			var add_column = function(date) {
				me.columns.push({
					id: date,
					name: frappe.datetime.str_to_user(date),
					field: date,
					formatter: me.currency_formatter,
					width: 100
				});
			};

			var build_columns = function(condition) {
				// add column for each date range
				for(var i=0; i <= date_diff; i++) {
					var date = frappe.datetime.add_days(me.from_date, i);
					if(!condition) { condition = function () { return true; }; }

					if(condition(date)) { add_column(date); }
					me.last_date = date;

					if(me.columns.length) {
						me.column_map[date] = me.columns[me.columns.length-1];
					}
				}
			};

			// make columns for all date ranges
			if(range=='Daily') {
				build_columns();
			} else if(range=='Weekly') {
				build_columns(function(date) {
					if(!me.last_date) { return true; }
					return !(frappe.datetime.get_diff(date, me.from_date) % 7);
				});
			} else if(range=='Monthly') {
				build_columns(function(date) {
					if(!me.last_date) { return true; }
					return frappe.datetime.str_to_obj(me.last_date).getMonth() != frappe.datetime.str_to_obj(date).getMonth();
				});
			} else if(range=='Quarterly') {
				build_columns(function(date) {
					if(!me.last_date) { return true; }
					return frappe.datetime.str_to_obj(date).getDate()==1 && in_list([0,3,6,9], frappe.datetime.str_to_obj(date).getMonth());
				});
			} else if(range=='Yearly') {
				build_columns(function(date) {
					if(!me.last_date) { return true; }
					return $.map(frappe.report_dump.data['Fiscal Year'], function(v) {
						return date==v.year_start_date ? true : null;
					}).length;
				});

			}

			// set label as last date of period
			$.each(this.columns, function(i, col) {
				col.name = me.columns[i+1]
					? frappe.datetime.str_to_user(frappe.datetime.add_days(me.columns[i+1].id, -1))
					: frappe.datetime.str_to_user(me.to_date);
			});
		},
		trigger_refresh_on_change: function(filters) {
			var me = this;
			$.each(filters, function(i, f) {
				me.filter_inputs[f] && me.filter_inputs[f].on("change", function() {
					me.refresh();
				});
			});
		}
	});

	frappe.views.GridReportWithPlot = frappe.views.GridReport.extend({
		setup_chart: function() {
			if (in_list(["Daily", "Weekly"], this.filter_inputs.range.val())) {
				this.chart_area.toggle(false);
				return;
			} else {
				this.chart_area.toggle(true);
			}
			var chart_data = this.get_chart_data ? this.get_chart_data() : null;

			var parent = this.wrapper.find('.chart')[0];
			this.chart = new Chart(parent, {
				height: 200,
				data: chart_data,
				type: 'line'
			});
		},

		get_chart_data: function() {
			var me = this;
			var plottable_cols = [];
			$.each(me.columns, function(idx, col) {
				if(col.formatter==me.currency_formatter && !col.hidden && col.plot!==false) {
					plottable_cols.push(col.field);
				}
			});

			var data = {
				labels: plottable_cols,
				datasets: []
			};

			$.each(this.data, function(i, item) {
				if (item.checked) {
					var dataset = {};
					dataset.name = item.name;
					dataset.values = [];
					$.each(plottable_cols, function(idx, col) {
						dataset.values.push(item[col]);
					});
					data["datasets"].push(dataset);
				}
			});
			return data;
		}
	});


	frappe.views.TreeGridReport = frappe.views.GridReportWithPlot.extend({
		make_transaction_list: function(parent_doctype, doctype) {
			var me = this;
			var tmap = {};
			$.each(frappe.report_dump.data[doctype], function(i, v) {
				if(!tmap[v.parent]) { tmap[v.parent] = []; }
				tmap[v.parent].push(v);
			});
			if (!this.tl) { this.tl = {}; }
			if (!this.tl[parent_doctype]) { this.tl[parent_doctype] = []; }

			$.each(frappe.report_dump.data[parent_doctype], function(i, parent) {
				if(tmap[parent.name]) {
					$.each(tmap[parent.name], function(i, d) {
						me.tl[parent_doctype].push($.extend(copy_dict(parent), d));
					});
				}
			});
		},
		add_tree_grid_events: function() {
			var me = this;
			this.grid.onClick.subscribe(function(e, args) {
				if ($(e.target).hasClass("toggle")) {
					var item = me.dataView.getItem(args.row);
					if (item) {
						if (!item._collapsed) {
							item._collapsed = true;
						} else {
							item._collapsed = false;
						}

						me.dataView.updateItem(item.id, item);
					}
					e.stopImmediatePropagation();
				}
			});
		},
		tree_formatter: function(row, cell, value, columnDef, dataContext) {
			var me = frappe.cur_grid_report;
			var data = me.data;
			var spacer = "<span style='display:inline-block;height:1px;width:" +
				(15 * dataContext["indent"]) + "px'></span>";
			var idx = me.dataView.getIdxById(dataContext.id);
			var link = me.tree_grid.formatter(dataContext);

			if(dataContext.doctype) {
				link += me.get_link_open_icon(dataContext.doctype, dataContext.name);
			}

			if (data[idx + 1] && data[idx + 1].indent > data[idx].indent) {
				if (dataContext._collapsed) {
					return spacer + " <span class='toggle expand'></span>&nbsp;" + link;
				} else {
					return spacer + " <span class='toggle collapse'></span>&nbsp;" + link;
				}
			} else {
				return spacer + " <span class='toggle'></span>&nbsp;" + link;
			}
		},
		tree_dataview_filter: function(item) {
			var me = frappe.cur_grid_report;
			if(!me.apply_filters(item)) { return false; }

			var parent = item[me.tree_grid.parent_field];
			while (parent) {
				if (me.item_by_name[parent]._collapsed) {
					return false;
				}
				parent = me.parent_map[parent];
			}
			return true;
		},
		prepare_tree: function(item_dt, group_dt) {
			var group_data = frappe.report_dump.data[group_dt];
			var item_data = frappe.report_dump.data[item_dt];

			// prepare map with child in respective group
			var me = this;
			var item_group_map = {};
			var group_ids = group_data.map(function (v) { return v.id; });

			$.each(item_data, function(i, item) {
				var parent = item[me.tree_grid.parent_field];
				if(!item_group_map[parent]) { item_group_map[parent] = []; }
				if(group_ids.indexOf(item.name)==-1) {
					item_group_map[parent].push(item);
				} else {
					frappe.msgprint(__("Ignoring Item {0}, because a group exists with the same name!", [item.name.bold()]));
				}
			});

			// arrange items besides their parent item groups
			var items = [];
			$.each(group_data, function(i, group){
				group.is_group = true;
				items.push(group);
				items = items.concat(item_group_map[group.name] || []);
			});
			return items;
		},
		set_indent: function() {
			var me = this;
			$.each(this.data, function(i, d) {
				var indent = 0;
				var parent = me.parent_map[d.name];
				if(parent) {
					while(parent) {
						indent++;
						parent = me.parent_map[parent];
					}
				}
				d.indent = indent;
			});
		},

		export: function() {
			var msgbox =	frappe.msgprint($.format('<p>{0}</p>\
			<p><input type="checkbox" name="with_groups" checked="checked"> {1}</p>\
			<p><input type="checkbox" name="with_ledgers" checked="checked"> {2}</p>\
			<p><button class="btn btn-primary"> {3}</button>', [
					__('Select To Download:'),
					__('With Groups'),
					__('With Ledgers'),
					__('Download')
				]));

			var me = this;

			$(msgbox.body).find("button").click(function() {
				var with_groups = $(msgbox.body).find("[name='with_groups']").prop("checked");
				var with_ledgers = $(msgbox.body).find("[name='with_ledgers']").prop("checked");

				var data = frappe.slickgrid_tools.get_view_data(me.columns, me.data,
					function(row, item) {
						if(with_groups) {
							// add row
							for(var i=0; i<item.indent; i++) { row[0] = "   " + row[0]; }
						}
						if(with_groups && (item.is_group == 1 || item.is_group)) {
							return true;
						}
						if(with_ledgers && (item.is_group != 1 && !item.is_group)) {
							return true;
						}

						return false;
					});

				frappe.tools.downloadify(data, ["Report Manager", "System Manager"], me.title);
				return false;
			});

			return false;
		},

	});

	frappe.templates['print_grid'] = ' {% if title %} <h2>{{ __(title) }}</h2> <hr> {% endif %} {% if subtitle %} {{ subtitle }} <hr> {% endif %} <table class="table table-bordered">          <thead>         <tr>         {% for col in columns %}             {% if col.name && col._id !== "_check" %}             <th style="min-width: {{ col.minWidth }}px"                 {% if col.docfield && frappe.model.is_numeric_field(col.docfield) %}                     class="text-right"                 {% endif %}>{{ __(col.name) }}</th>             {% endif %}         {% endfor %}         </tr>     </thead>          <tbody>         {% for row in data %}             <tr>             {% for col in columns %}                 {% if col.name && col._id !== "_check" %}                      {% var value = col.fieldname ? row[col.fieldname] : row[col.id]; %}                      <td>                         {{ col.formatter                          ? col.formatter(row._index, col._index, value, col, row, true)                             : (col.docfield ? frappe.format(value, col.docfield) : value) }}                     </td>                 {% endif %}             {% endfor %}             </tr>         {% endfor %}     </tbody> </table> ';

	frappe.templates['print_tree'] = '<!DOCTYPE html> <html lang="en">   <head>     <meta charset="utf-8">     <meta http-equiv="X-UA-Compatible" content="IE=edge">     <meta name="viewport" content="width=device-width, initial-scale=1">     <meta name="description" content="">     <meta name="author" content="">     <title>{{ title }}</title>     <link href="{{ base_url }}/assets/frappe/css/bootstrap.css" rel="stylesheet">  <link type="text/css" rel="stylesheet"   href="{{ base_url }}/assets/frappe/css/font-awesome.css">  <link rel="stylesheet" type="text/css" href="{{ base_url }}/assets/frappe/css/tree.css">   <style>   {{ print_css }}  </style>  <style>   .tree.opened::before,    .tree-node.opened::before,    .tree:last-child::after,    .tree-node:last-child::after {    z-index: 1;    border-left: 1px solid #d1d8dd;    background: none;   }   .tree a,   .tree-link {    text-decoration: none;    cursor: default;   }   .tree.opened > .tree-children > .tree-node > .tree-link::before,    .tree-node.opened > .tree-children > .tree-node > .tree-link::before {    border-top: 1px solid #d1d8dd;    z-index: 1;    background: none;   }   i.fa.fa-fw.fa-folder {    z-index: 2;    position: relative;   }   .tree:last-child::after, .tree-node:last-child::after {    display: none;   }   .tree-node-toolbar {    display: none;   }   i.octicon.octicon-primitive-dot.text-extra-muted {    width: 7px;    height: 7px;    border-radius: 50%;    background: #d1d8dd;    display: inline-block;    position: relative;    z-index: 2;   }    @media (max-width: 767px) {    ul.tree-children {     padding-left: 20px;    }   }  </style>   </head>   <body>    <div class="print-format-gutter">     {% if print_settings.repeat_header_footer %}    <div id="footer-html" class="visible-pdf">     {% if print_settings.letter_head && print_settings.letter_head.footer %}      <div class="letter-head-footer">       {{ print_settings.letter_head.footer }}      </div>     {% endif %}     <p class="text-center small page-number visible-pdf">      {{ __("Page {0} of {1}", [`<span class="page"></span>`, `<span class="topage"></span>`]) }}     </p>    </div>     {% endif %}      <div class="print-format {% if landscape %} landscape {% endif %}">      {% if print_settings.letter_head %}      <div {% if print_settings.repeat_header_footer %} id="header-html" class="hidden-pdf" {% endif %}>       <div class="letter-head">{{ print_settings.letter_head.header }}</div>      </div>     {% endif %}     <div class="tree opened">      {{ tree }}     </div>     </div>    </div>   </body> </html> ';

	exports.__moduleExports = clusterize_min;

	return exports;

}({}));
//# sourceMappingURL=report.min.js.map
